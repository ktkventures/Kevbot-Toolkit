// KevBot Toolkit v2.0 – Library-Centric Architecture
//
// V2 ARCHITECTURE OVERVIEW:
//   • Each TF interpreter (EMA Stack, VWAP, UT Bot, etc.) has its own input section
//   • Library-specific parameters replace generic "Parameter A/B/C" inputs
//   • Slot-based side table rendering (1-10 slots, user-assignable per library)
//   • Only enabled libraries consume request.security() calls (resource efficient)
//   • Designed for future custom toolkit generator (extractable library blocks)
//
// CHANGES FROM v1.1:
//   • Replaced generic "Side Module 1/2" with library-specific input sections
//   • Added slot-based side table renderer supporting up to 10 library rows
//   • Each library can be independently enabled/disabled
//   • Clear parameter names per library (e.g., "Short EMA" instead of "Parameter A")
//
// See docs/Side_Module_Architecture_v2.md for detailed architecture documentation.

//──────────────────────────────────────────────────────────────────────────────
// KevBot Toolkit v2.0 – LIBRARY-CENTRIC ARCHITECTURE
//──────────────────────────────────────────────────────────────────────────────

//@version=6
indicator("KevBot Toolkit v2.0 – Library-Centric", overlay = true, max_labels_count = 500)
plot(na, title="placeholder", display=display.none)

import yamigushi/KevBot_TimeUtils/1 as tu


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1. GLOBAL TOOLKIT SETTINGS
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
string GRP_GLOBAL = "1. Global Toolkit Settings"
bool   enableTopTable  = input.bool(true,  "Enable Top Table",          group = GRP_GLOBAL, tooltip="Show or hide the top-of-chart table that displays the outputs of all Top Modules.")
bool   enableSideTable = input.bool(true,  "Enable Side Table",         group = GRP_GLOBAL, tooltip="Show or hide the right-side multi-timeframe table that displays Side Module outputs.")
bool   useDarkTheme    = input.bool(true,  "Use Dark Theme Colors",     group = GRP_GLOBAL, tooltip="Enable the KevBot Toolkit dark color theme.")

// Timeframes
string GRP_TF = "1.1 Global Timeframe Configuration"

// Row 1: TF 1 & TF 2
bool   tf1_enabled = input.bool(true, "TF 1", group = GRP_TF, inline = "tf_row1", tooltip = "Enable this timeframe for scoring. Disabled TFs contribute no TH score.")
string tf1        = input.timeframe("1", "", group = GRP_TF, inline = "tf_row1")

bool   tf2_enabled = input.bool(true, "TF 2", group = GRP_TF, inline = "tf_row1", tooltip = "Enable this timeframe for scoring. Disabled TFs contribute no TH score.")
string tf2        = input.timeframe("5", "", group = GRP_TF, inline = "tf_row1")

// Row 2: TF 3 & TF 4
bool   tf3_enabled = input.bool(true, "TF 3", group = GRP_TF, inline = "tf_row2", tooltip = "Enable this timeframe for scoring. Disabled TFs contribute no TH score.")
string tf3        = input.timeframe("15", "", group = GRP_TF, inline = "tf_row2")

bool   tf4_enabled = input.bool(true, "TF 4", group = GRP_TF, inline = "tf_row2", tooltip = "Enable this timeframe for scoring. Disabled TFs contribute no TH score.")
string tf4        = input.timeframe("60", "", group = GRP_TF, inline = "tf_row2")

// Row 3: TF 5 & TF 6
bool   tf5_enabled = input.bool(true, "TF 5", group = GRP_TF, inline = "tf_row3", tooltip = "Enable this timeframe for scoring. Disabled TFs contribute no TH score.")
string tf5        = input.timeframe("240", "", group = GRP_TF, inline = "tf_row3")

bool   tf6_enabled = input.bool(true, "TF 6", group = GRP_TF, inline = "tf_row3", tooltip = "Enable this timeframe for scoring. Disabled TFs contribute no TH score.")
string tf6        = input.timeframe("D", "", group = GRP_TF, inline = "tf_row3")

// Confluence Grades
string GRP_CG = "1.2 Global Confluence Grades"
int gradeC_long = input.int(200, "Grade C Long Threshold", minval = 0, group = GRP_CG, tooltip="Minimum Long confluence score required to qualify as Grade C.")
int gradeB_long = input.int(250, "Grade B Long Threshold", minval = 0, group = GRP_CG, tooltip="Minimum Long confluence score required to qualify as Grade B.")
int gradeA_long = input.int(300, "Grade A Long Threshold", minval = 0, group = GRP_CG, tooltip="Minimum Long confluence score required to qualify as Grade A.")
int gradeC_short = input.int(200, "Grade C Short Threshold", minval = 0, group = GRP_CG, tooltip="Minimum Short confluence score required to qualify as Grade C.")
int gradeB_short = input.int(250, "Grade B Short Threshold", minval = 0, group = GRP_CG, tooltip="Minimum Short confluence score required to qualify as Grade B.")
int gradeA_short = input.int(300, "Grade A Short Threshold", minval = 0, group = GRP_CG, tooltip="Minimum Short confluence score required to qualify as Grade A.")

//label.new(bar_index, high, "TF1 = " + tf1 + "\nTF2 = " + tf2 + "\nTF3 = " + tf3 + "\nTF4 = " + tf4 + "\nTF5 = " + tf5 + "\nTF6 = " + tf6)


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2. CONFLUENCE SUMMARY MODULES
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
string GRP_CSM = "2. Confluence Summary Modules"
bool showCSM_long  = input.bool(false, "Show Long Confluence Module", group = GRP_CSM, inline="csm_long", tooltip="Displays the Long Confluence summary module in the Top Table. Does not affect trading logic.")
string csmLongName = input.string("", "Custom Name", group = GRP_CSM, inline="csm_long", tooltip="Optional display name for the Long Confluence Module.")
bool showCSM_short = input.bool(false, "Show Short Confluence Module", group = GRP_CSM, inline="csm_short", tooltip="Displays the Short Confluence summary module in the Top Table. Does not affect trading logic.")
string csmShortName= input.string("", "Custom Name", group = GRP_CSM, inline="csm_short", tooltip="Optional display name for the Short Confluence Module.")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 3. POSITION SIZING MODULE
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
string GRP_POS = "3. Position Sizing Module"
bool showSizer = input.bool(false, "Show Position Sizing Module", group = GRP_POS, inline="ps_row", tooltip="Displays this module in the Top Table (visual only). Does not affect trade logic.")
string sizerName = input.string("", "Custom Name", group = GRP_POS, inline="ps_row", tooltip="Name shown in the Top Table for this module.")
string sizer_entry = input.string("Any Entry Trigger", "Position Entry Method", options=["Any Entry Trigger","Entry Trigger + Grade C","Entry Trigger + Grade B","Entry Trigger + Grade A","Library Custom"], group=GRP_POS, tooltip="Controls when a position is allowed to open, optionally requiring specific confluence grades.")
bool   sizerAllowMulti = input.bool(false, "Allow Multiple Entries Per Trade", group=GRP_POS, tooltip="If enabled, the system may stack additional entries while a trade is open.")
int    sizerMaxEntries = input.int(1, "Max Entries Per Trade", minval=1, group=GRP_POS, tooltip="Limits how many entries may be stacked into a single trade.")
string sizer_exit = input.string("First Exit Trigger", "Position Exit Method", options=["First Exit Trigger","Exit Trigger + Grade C","Exit Trigger + Grade B","Exit Trigger + Grade A","Library Custom"], group=GRP_POS, tooltip="Determines when a trade should close, optionally requiring a confluence grade.")
bool   sizer_exitEOD = input.bool(false, "Exit at End of Day", group=GRP_POS, tooltip="Closes all positions at the end of the trading day as a safety fallback.")

// Safety Stop Loss
string GRP_POS_SL = "3.1 Safety Stop Loss"
string sl_method = input.string("ATR", "SL Method", options = ["ATR","Fixed Dollar","Percentage","Candle Wicks","Library Custom"], group = GRP_POS_SL, inline="slrow", tooltip="Safety‑based stop‑loss. Acts as a protective anchor for bots and a fallback chart‑based stop if no exit trigger occurs.")
bool   sl_show   = input.bool(false, "Show SL on chart", group = GRP_POS_SL, inline="slrow", tooltip="Plots the safety stop‑loss level visually.")
int    sl_atrPer = input.int(14, "ATR Period", group = GRP_POS_SL)
float  sl_atrMult= input.float(2.0, "ATR Multiplier", group = GRP_POS_SL)
float  sl_fixed  = input.float(1.0, "Fixed Dollar Stop", group = GRP_POS_SL)
float  sl_pct    = input.float(1.0, "Percentage Stop", group = GRP_POS_SL)
int    sl_lookback = input.int(1, "Lo/Hi Lookback Bars", group = GRP_POS_SL)
float  sl_pad    = input.float(0.1, "Lo/Hi Padding", group = GRP_POS_SL)

// Safety Take Profit
// Safety Take Profit
string GRP_POS_TP = "3.2 Safety Take Profit"
string tp_method = input.string("Risk:Reward Target", "TP Method", options = ["Risk:Reward Target","ATR","Fixed Dollar","Percentage","Candle Wicks","Library Custom"], group = GRP_POS_TP, inline="tprow")
bool   tp_show   = input.bool(false, "Show TP on chart", group = GRP_POS_TP, inline="tprow")
float  tp_rr     = input.float(2.0, "R:R Target", group = GRP_POS_TP)
int    tp_atrPer = input.int(14, "ATR Period", group = GRP_POS_TP)
float  tp_atrMult= input.float(2.0, "ATR Multiplier", group = GRP_POS_TP)
float  tp_fixed  = input.float(1.0, "Fixed Dollar Target", group = GRP_POS_TP)
float  tp_pct    = input.float(1.0, "Percentage Target", group = GRP_POS_TP)
int    tp_lookback = input.int(1, "Lo/Hi Lookback Bars", group = GRP_POS_TP)
float  tp_pad    = input.float(0.1, "Lo/Hi Padding", group = GRP_POS_TP)



// Account & Risk
string GRP_POS_ACC = "3.3 Account / Risk Configuration"
float acctSize     = input.float(25000, "Account Size", group = GRP_POS_ACC)
string riskMode    = input.string("Fixed $ Risk", "Risk Mode", options = ["Share Qty","Fixed $ Risk","Percentage Risk"], group = GRP_POS_ACC)
int    defShares   = input.int(100, "Default Share Qty", group = GRP_POS_ACC)
float  defRisk    = input.float(100, "Default Risk Value (Fixed)", group = GRP_POS_ACC)
float  defRiskPct  = input.float(1.0, "Default Risk Value (Percent)", group = GRP_POS_ACC)

// Risk Multipliers
string GRP_POS_MULT = "3.4 Risk Multipliers"
float mult_CL = input.float(1.0, "Grade C Long Risk Multiplier", group = GRP_POS_MULT, tooltip="Multiplies the position size based on Long Grade C confluence. Applied on top of the Risk Mode defaults.")
float mult_BL = input.float(1.0, "Grade B Long Risk Multiplier", group = GRP_POS_MULT, tooltip="Multiplies the position size when Long Grade B confluence is met.")
float mult_AL = input.float(1.0, "Grade A Long Risk Multiplier", group = GRP_POS_MULT, tooltip="Multiplies the position size when Long Grade A confluence is met.")
float mult_CS = input.float(1.0, "Grade C Short Risk Multiplier", group = GRP_POS_MULT, tooltip="Multiplies the position size when Short Grade C confluence is met.")
float mult_BS = input.float(1.0, "Grade B Short Risk Multiplier", group = GRP_POS_MULT, tooltip="Multiplies the position size when Short Grade B confluence is met.")
float mult_AS = input.float(1.0, "Grade A Short Risk Multiplier", group = GRP_POS_MULT, tooltip="Multiplies the position size when Short Grade A confluence is met.")

// Position Labels
string GRP_POS_LBL = "3.5 Position Labels"
bool lbl_warn  = input.bool(true, "Inherit Bullish/Warning Label Text", group = GRP_POS_LBL, tooltip="Displays the system's bullish/bearish label text inside the Position Label. These enhanced labels replace basic SL/TP labels and include expanded trade information.")
bool lbl_grade = input.bool(true, "Confluence Grade (A,B,C)", group = GRP_POS_LBL, tooltip="Adds the detected confluence grade (A/B/C) into the Position Label for clarity.")
bool lbl_type  = input.bool(true, "Trade Type (Long or Short)", group = GRP_POS_LBL, tooltip="Adds whether the trade was Long or Short to the Position Label.")
bool lbl_qty   = input.bool(true, "Qty", group = GRP_POS_LBL, tooltip="Shows the calculated position size (quantity) on entry labels.")
bool lbl_risk  = input.bool(true, "$Risk", group = GRP_POS_LBL, tooltip="Displays the actual dollar risk taken on the trade, based on Risk Mode and Safety Stop distance.")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 4. BACKTESTING MODULE
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
string GRP_BACK = "4. Backtesting Module"
bool showBack   = input.bool(false, "Show Backtest KPI Module", group = GRP_BACK, inline="back_row")
string backName = input.string("", "Custom Name", group = GRP_BACK, inline="back_row")

string GRP_BACK_DATA = "4.1 Data & Lookback Config"
string backWindow = input.string("Entire Chart", "Backtest Window", options = ["Entire Chart","Fixed Bars","Date Range"], group = GRP_BACK_DATA)
int    backBars   = input.int(2000, "Window (Bars)", minval = 1, group = GRP_BACK_DATA)
const int BACK_START_DEF = 1577836800000 // 2020-01-01 00:00 UTC
int    backStartDate = input.time(BACK_START_DEF, "Window (Start Date)", group = GRP_BACK_DATA, inline="wstart")

bool   backUseEnd = input.bool(false, "Window (End)", group = GRP_BACK_DATA, inline="wend")
const int BACK_END_DEF = 1893456000000 // 2030-01-01 00:00 UTC
int    backEndDate   = input.time(BACK_END_DEF, "End Date", group = GRP_BACK_DATA, inline="wend")


string GRP_BACK_FILT = "4.2 Backtest Filters"
string backSession   = input.session("0000-2359", "Time of Day Filter", group = GRP_BACK_FILT)
bool   backUseDOW_M  = input.bool(true,  "Mon",  group = GRP_BACK_FILT, inline="dow1")
bool   backUseDOW_T  = input.bool(true,  "Tues", group = GRP_BACK_FILT, inline="dow1")
bool   backUseDOW_W  = input.bool(true,  "Weds", group = GRP_BACK_FILT, inline="dow1")
bool   backUseDOW_Th = input.bool(true,  "Thurs",group = GRP_BACK_FILT, inline="dow1")
bool   backUseDOW_F  = input.bool(true,  "Fri",  group = GRP_BACK_FILT, inline="dow1")
bool   backUseDOW_Sa = input.bool(false, "Sat",  group = GRP_BACK_FILT, inline="dow1")
bool   backUseDOW_Su = input.bool(false, "Sun",  group = GRP_BACK_FILT, inline="dow1")


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5. TOP MODULE 1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
string GRP_TOP1 = "5. Top Module 1"
bool   top1_enabled = input.bool(false, "Enable Top Module 1", group = GRP_TOP1, tooltip="Enables this Top Module. If the Top Table is visible, the module will appear there. Its enabled outputs also contribute their TH Scores to confluence calculations.")
string top1_library = input.string("None", "Library", options = ["None","Placeholder Top Library"], group = GRP_TOP1, inline="top1_row1")
string top1_name    = input.string("", "Custom Name", group = GRP_TOP1, inline="top1_row1")

// Parameters A–F
float top1_paramA = input.float(0.0, "Parameter A", group = GRP_TOP1, inline="top1_rowA")
float top1_paramB = input.float(0.0, "Parameter B", group = GRP_TOP1, inline="top1_rowA")
float top1_paramC = input.float(0.0, "Parameter C", group = GRP_TOP1, inline="top1_rowB")
float top1_paramD = input.float(0.0, "Parameter D", group = GRP_TOP1, inline="top1_rowB")
float top1_paramE = input.float(0.0, "Parameter E", group = GRP_TOP1, inline="top1_rowC")
float top1_paramF = input.float(0.0, "Parameter F", group = GRP_TOP1, inline="top1_rowC")

// Output 1
string GRP_TOP1_O1 = "5.1 Top Module 1 – Output 1"
bool   top1_o1_enabled = input.bool(false, "Enable Output 1", group = GRP_TOP1_O1, tooltip="Activates this output. When enabled, its threshold score (TH Score) is included in the module’s total confluence contribution.")
string top1_o1_source  = input.string("None", "Source", options=["None","Output A","Output B","Output C","Output D"], group=GRP_TOP1_O1, inline="o1_row1")
bool   top1_o1_required= input.bool(false, "Required", group = GRP_TOP1_O1, inline="o1_row1", tooltip="If enabled, this condition becomes mandatory: it must be true for entries or exits (depending on context). Required acts as a hard confluence filter.")
bool   top1_o1_invLbl  = input.bool(false, "Inv Label", group = GRP_TOP1_O1, inline="o1_row1", tooltip="Required makes this output a mandatory condition for entries. Inv Label plots invisible markers so the data can be exported for journaling and analytics.")
string top1_o1_dir     = input.string("Both", "Direction", options=["Long","Short","Both"], group=GRP_TOP1_O1, inline="o1_row2")
string top1_o1_mode    = input.string("Boolean", "Mode", options=["Boolean","Greater Than","Less Than","Between","Equals","Library Default"], group=GRP_TOP1_O1, inline="o1_row2")
float  top1_o1_valA    = input.float(0.0, "Value A", group = GRP_TOP1_O1, inline="o1_row3")
float  top1_o1_valB    = input.float(0.0, "Value B", group = GRP_TOP1_O1, inline="o1_row3")
int    top1_o1_score   = input.int(0, "TH Score", group = GRP_TOP1_O1, inline="o1_row4")

// Output 2
string GRP_TOP1_O2 = "5.2 Top Module 1 – Output 2"
bool   top1_o2_enabled = input.bool(false, "Enable Output 2", group = GRP_TOP1_O2)
string top1_o2_source  = input.string("None", "Source", options=["None","Output A","Output B","Output C","Output D"], group=GRP_TOP1_O2, inline="o2_row1")
bool   top1_o2_required= input.bool(false, "Required", group = GRP_TOP1_O2, inline="o2_row1")
bool   top1_o2_invLbl  = input.bool(false, "Inv Label", group = GRP_TOP1_O2, inline="o2_row1")
string top1_o2_dir     = input.string("Both", "Direction", options=["Long","Short","Both"], group=GRP_TOP1_O2, inline="o2_row2")
string top1_o2_mode    = input.string("Boolean", "Mode", options=["Boolean","Greater Than","Less Than","Between","Equals","Library Default"], group=GRP_TOP1_O2, inline="o2_row2")
float  top1_o2_valA    = input.float(0.0, "Value A", group = GRP_TOP1_O2, inline="o2_row3")
float  top1_o2_valB    = input.float(0.0, "Value B", group = GRP_TOP1_O2, inline="o2_row3")
int    top1_o2_score   = input.int(0, "TH Score", group = GRP_TOP1_O2, inline="o2_row4")

// Output 3
string GRP_TOP1_O3 = "5.3 Top Module 1 – Output 3"
bool   top1_o3_enabled = input.bool(false, "Enable Output 3", group = GRP_TOP1_O3)
string top1_o3_source  = input.string("None", "Source", options=["None","Output A","Output B","Output C","Output D"], group=GRP_TOP1_O3, inline="o3_row1")
bool   top1_o3_required= input.bool(false, "Required", group = GRP_TOP1_O3, inline="o3_row1")
bool   top1_o3_invLbl  = input.bool(false, "Inv Label", group = GRP_TOP1_O3, inline="o3_row1")
string top1_o3_dir     = input.string("Both", "Direction", options=["Long","Short","Both"], group=GRP_TOP1_O3, inline="o3_row2")
string top1_o3_mode    = input.string("Boolean", "Mode", options=["Boolean","Greater Than","Less Than","Between","Equals","Library Default"], group=GRP_TOP1_O3, inline="o3_row2")
float  top1_o3_valA    = input.float(0.0, "Value A", group = GRP_TOP1_O3, inline="o3_row3")
float  top1_o3_valB    = input.float(0.0, "Value B", group = GRP_TOP1_O3, inline="o3_row3")
int    top1_o3_score   = input.int(0, "TH Score", group = GRP_TOP1_O3, inline="o3_row4")

// Output 4
string GRP_TOP1_O4 = "5.4 Top Module 1 – Output 4"
bool   top1_o4_enabled = input.bool(false, "Enable Output 4", group = GRP_TOP1_O4)
string top1_o4_source  = input.string("None", "Source", options=["None","Output A","Output B","Output C","Output D"], group=GRP_TOP1_O4, inline="o4_row1")
bool   top1_o4_required= input.bool(false, "Required", group = GRP_TOP1_O4, inline="o4_row1")
bool   top1_o4_invLbl  = input.bool(false, "Inv Label", group = GRP_TOP1_O4, inline="o4_row1")
string top1_o4_dir     = input.string("Both", "Direction", options=["Long","Short","Both"], group=GRP_TOP1_O4, inline="o4_row2")
string top1_o4_mode    = input.string("Boolean", "Mode", options=["Boolean","Greater Than","Less Than","Between","Equals","Library Default"], group=GRP_TOP1_O4, inline="o4_row2")
float  top1_o4_valA    = input.float(0.0, "Value A", group = GRP_TOP1_O4, inline="o4_row3")
float  top1_o4_valB    = input.float(0.0, "Value B", group = GRP_TOP1_O4, inline="o4_row3")
int    top1_o4_score   = input.int(0, "TH Score", group = GRP_TOP1_O4, inline="o4_row4")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5-1. VWAP (TOP TABLE CONFLUENCE INTERPRETER)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// Displays Daily, Weekly, and Monthly anchored VWAP zones in the Top Table.
// Each output shows the current price position relative to that VWAP's
// standard deviation bands, providing multi-timeframe VWAP context.
//
// Zone Labels: >+2σ, >+1σ, >V, @V, <V, <-1σ, <-2σ
// Color Coding: Green (Long match), Red (Short match), Yellow (monitored), Gray (off)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- VWAP: MAIN SETTINGS ---
string GRP_TOP_VWAP = "5-1. VWAP"
bool   lib_vwap_enabled = input.bool(false, "Enable", group = GRP_TOP_VWAP, tooltip = "Enable VWAP top table interpreter showing Daily, Weekly, and Monthly anchored VWAP zones.")
string lib_vwap_name    = input.string("VWAP", "Display Name", group = GRP_TOP_VWAP, tooltip = "Custom name shown in top table header.")

// --- VWAP: PARAMETERS ---
string GRP_TOP_VWAP_PARAMS = "5-1.1 VWAP – Parameters"
float  lib_vwap_band1 = input.float(1.0, "Band 1 Multiplier (σ)", minval = 0.1, group = GRP_TOP_VWAP_PARAMS, tooltip = "Standard deviation multiplier for inner bands (+1σ/-1σ).")
float  lib_vwap_band2 = input.float(2.0, "Band 2 Multiplier (σ)", minval = 0.1, group = GRP_TOP_VWAP_PARAMS, tooltip = "Standard deviation multiplier for outer bands (+2σ/-2σ).")

// Zone condition options for dropdowns
string _VWAP_COND_NONE = "None"
string _VWAP_COND_ABOVE = "Above VWAP"
string _VWAP_COND_AT_ABOVE = "At/Above VWAP"
string _VWAP_COND_AT = "At VWAP"
string _VWAP_COND_AT_BELOW = "At/Below VWAP"
string _VWAP_COND_BELOW = "Below VWAP"
string _VWAP_COND_EXT_ABOVE = "Extended Above"
string _VWAP_COND_EXT_BELOW = "Extended Below"
string _VWAP_COND_EXTREME_HI = "Extreme High"
string _VWAP_COND_EXTREME_LO = "Extreme Low"

// --- VWAP: DAILY OUTPUT ---
string GRP_TOP_VWAP_D = "5-1.2 VWAP – Daily"
string lib_vwap_D_long  = input.string("Above VWAP", "Long Condition", options = ["None", "Above VWAP", "At/Above VWAP", "At VWAP", "At/Below VWAP", "Below VWAP", "Extended Above", "Extended Below", "Extreme High", "Extreme Low"], group = GRP_TOP_VWAP_D, tooltip = "Zone(s) that qualify as bullish confluence for Daily VWAP.")
string lib_vwap_D_short = input.string("Below VWAP", "Short Condition", options = ["None", "Above VWAP", "At/Above VWAP", "At VWAP", "At/Below VWAP", "Below VWAP", "Extended Above", "Extended Below", "Extreme High", "Extreme Low"], group = GRP_TOP_VWAP_D, tooltip = "Zone(s) that qualify as bearish confluence for Daily VWAP.")
int    lib_vwap_D_score = input.int(50, "TH Score", minval = 0, group = GRP_TOP_VWAP_D, tooltip = "Threshold score contribution when condition is met.")
bool   lib_vwap_D_req   = input.bool(false, "Required", group = GRP_TOP_VWAP_D, tooltip = "If enabled, this condition must be met for entries.")

// --- VWAP: WEEKLY OUTPUT ---
string GRP_TOP_VWAP_W = "5-1.3 VWAP – Weekly"
string lib_vwap_W_long  = input.string("Above VWAP", "Long Condition", options = ["None", "Above VWAP", "At/Above VWAP", "At VWAP", "At/Below VWAP", "Below VWAP", "Extended Above", "Extended Below", "Extreme High", "Extreme Low"], group = GRP_TOP_VWAP_W, tooltip = "Zone(s) that qualify as bullish confluence for Weekly VWAP.")
string lib_vwap_W_short = input.string("Below VWAP", "Short Condition", options = ["None", "Above VWAP", "At/Above VWAP", "At VWAP", "At/Below VWAP", "Below VWAP", "Extended Above", "Extended Below", "Extreme High", "Extreme Low"], group = GRP_TOP_VWAP_W, tooltip = "Zone(s) that qualify as bearish confluence for Weekly VWAP.")
int    lib_vwap_W_score = input.int(50, "TH Score", minval = 0, group = GRP_TOP_VWAP_W, tooltip = "Threshold score contribution when condition is met.")
bool   lib_vwap_W_req   = input.bool(false, "Required", group = GRP_TOP_VWAP_W, tooltip = "If enabled, this condition must be met for entries.")

// --- VWAP: MONTHLY OUTPUT ---
string GRP_TOP_VWAP_M = "5-1.4 VWAP – Monthly"
string lib_vwap_M_long  = input.string("Above VWAP", "Long Condition", options = ["None", "Above VWAP", "At/Above VWAP", "At VWAP", "At/Below VWAP", "Below VWAP", "Extended Above", "Extended Below", "Extreme High", "Extreme Low"], group = GRP_TOP_VWAP_M, tooltip = "Zone(s) that qualify as bullish confluence for Monthly VWAP.")
string lib_vwap_M_short = input.string("Below VWAP", "Short Condition", options = ["None", "Above VWAP", "At/Above VWAP", "At VWAP", "At/Below VWAP", "Below VWAP", "Extended Above", "Extended Below", "Extreme High", "Extreme Low"], group = GRP_TOP_VWAP_M, tooltip = "Zone(s) that qualify as bearish confluence for Monthly VWAP.")
int    lib_vwap_M_score = input.int(50, "TH Score", minval = 0, group = GRP_TOP_VWAP_M, tooltip = "Threshold score contribution when condition is met.")
bool   lib_vwap_M_req   = input.bool(false, "Required", group = GRP_TOP_VWAP_M, tooltip = "If enabled, this condition must be met for entries.")


// NOTE: Legacy Side Module 1/2 inputs removed in v2.0 transition
// See legacy/KevBot Toolkit v1.1 - Hybrid Architecture.txt for reference
// V2 uses library-specific input sections below (6-1. EMA Stack, 6-2. RVOL, etc.)

// Placeholder variables for legacy code compatibility during transition
// These will be removed once all downstream references are cleaned up
bool side1_enabled = false
bool side2_enabled = false
string side1_library = "None"
string side2_library = "None"

// NOTE: Legacy Side Module 1/2 inputs removed in v2.0 transition
// V2 uses library-specific input sections (6-1. EMA Stack, 6-2. RVOL, etc.)


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY: EMA_STACK ██████
// GENERATOR_ID: EMA_STACK
// SECURITY_CALLS: 6
// DEPENDENCIES: yamigushi/KevBot_TF_EMA_Stack/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- EMA_STACK: INPUTS ---
string GRP_LIB_EMA      = "6-1. EMA Stack"
bool   lib_ema_enabled  = input.bool(false, "Enable", group = GRP_LIB_EMA, tooltip = "Enable EMA Stack interpreter for confluence analysis.")
int    lib_ema_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_EMA, tooltip = "0 = Hidden, 1-10 = Table row position. Lower numbers appear higher in table.")
string lib_ema_name     = input.string("EMA Stack", "Display Name", group = GRP_LIB_EMA, tooltip = "Custom name shown in side table.")

// EMA Stack Parameters
string GRP_LIB_EMA_PARAMS = "6-1.1 EMA Stack – Parameters"
int    lib_ema_short    = input.int(10, "Short EMA Length", minval = 1, group = GRP_LIB_EMA_PARAMS)
int    lib_ema_medium   = input.int(20, "Medium EMA Length", minval = 1, group = GRP_LIB_EMA_PARAMS)
int    lib_ema_long     = input.int(50, "Long EMA Length", minval = 1, group = GRP_LIB_EMA_PARAMS)

// EMA Stack Entry/Exit Configuration
string GRP_LIB_EMA_LE   = "6-1.2 EMA Stack – Long Entry"
bool   lib_ema_LE_enable = input.bool(true, "Long Entry Trigger", group = GRP_LIB_EMA_LE, inline = "ema_le1")
string lib_ema_LE_source = input.string("S > M Cross", "", options = ["None","S > M Cross","S < M Cross","S > L Cross","S < L Cross","M > L Cross","M < L Cross"], group = GRP_LIB_EMA_LE, inline = "ema_le1", tooltip = "Short EMA crosses above Medium EMA")
string lib_ema_LE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_EMA_LE, inline = "ema_le2")
bool   lib_ema_LE_bull   = input.bool(true, "Bullish Label", group = GRP_LIB_EMA_LE, inline = "ema_le2")

string GRP_LIB_EMA_LE_TF = "6-1.2.1 Long Entry – Confluences by TF"
bool   lib_ema_LEC_enable = input.bool(true, "Long Entry Confluence", group = GRP_LIB_EMA_LE_TF, inline = "ema_lec1")
string lib_ema_LEC_func   = input.string("SML (Bull)", "", options = ["None","SML (Bull)","LMS (Bear)","SLM","MSL","MLS","LSM"], group = GRP_LIB_EMA_LE_TF, inline = "ema_lec1", tooltip = "SML = Short > Medium > Long (Bullish Stack)")
bool   lib_ema_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_EMA_LE_TF, inline = "ema_lec1")
int    lib_ema_LE_tf1     = input.int(50, "TF 1 Score", inline = "ema_le_tf1", group = GRP_LIB_EMA_LE_TF)
bool   lib_ema_LE_tf1_req = input.bool(false, "Required", inline = "ema_le_tf1", group = GRP_LIB_EMA_LE_TF)
int    lib_ema_LE_tf2     = input.int(50, "TF 2 Score", inline = "ema_le_tf2", group = GRP_LIB_EMA_LE_TF)
bool   lib_ema_LE_tf2_req = input.bool(false, "Required", inline = "ema_le_tf2", group = GRP_LIB_EMA_LE_TF)
int    lib_ema_LE_tf3     = input.int(50, "TF 3 Score", inline = "ema_le_tf3", group = GRP_LIB_EMA_LE_TF)
bool   lib_ema_LE_tf3_req = input.bool(false, "Required", inline = "ema_le_tf3", group = GRP_LIB_EMA_LE_TF)
int    lib_ema_LE_tf4     = input.int(0, "TF 4 Score", inline = "ema_le_tf4", group = GRP_LIB_EMA_LE_TF)
bool   lib_ema_LE_tf4_req = input.bool(false, "Required", inline = "ema_le_tf4", group = GRP_LIB_EMA_LE_TF)
int    lib_ema_LE_tf5     = input.int(0, "TF 5 Score", inline = "ema_le_tf5", group = GRP_LIB_EMA_LE_TF)
bool   lib_ema_LE_tf5_req = input.bool(false, "Required", inline = "ema_le_tf5", group = GRP_LIB_EMA_LE_TF)
int    lib_ema_LE_tf6     = input.int(0, "TF 6 Score", inline = "ema_le_tf6", group = GRP_LIB_EMA_LE_TF)
bool   lib_ema_LE_tf6_req = input.bool(false, "Required", inline = "ema_le_tf6", group = GRP_LIB_EMA_LE_TF)

string GRP_LIB_EMA_SE   = "6-1.3 EMA Stack – Short Entry"
bool   lib_ema_SE_enable = input.bool(true, "Short Entry Trigger", group = GRP_LIB_EMA_SE, inline = "ema_se1")
string lib_ema_SE_source = input.string("S < M Cross", "", options = ["None","S > M Cross","S < M Cross","S > L Cross","S < L Cross","M > L Cross","M < L Cross"], group = GRP_LIB_EMA_SE, inline = "ema_se1", tooltip = "Short EMA crosses below Medium EMA")
string lib_ema_SE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_EMA_SE, inline = "ema_se2")
bool   lib_ema_SE_bear   = input.bool(true, "Bearish Label", group = GRP_LIB_EMA_SE, inline = "ema_se2")

string GRP_LIB_EMA_SE_TF = "6-1.3.1 Short Entry – Confluences by TF"
bool   lib_ema_SEC_enable = input.bool(true, "Short Entry Confluence", group = GRP_LIB_EMA_SE_TF, inline = "ema_sec1")
string lib_ema_SEC_func   = input.string("LMS (Bear)", "", options = ["None","SML (Bull)","LMS (Bear)","SLM","MSL","MLS","LSM"], group = GRP_LIB_EMA_SE_TF, inline = "ema_sec1", tooltip = "LMS = Long > Medium > Short (Bearish Stack)")
bool   lib_ema_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_EMA_SE_TF, inline = "ema_sec1")
int    lib_ema_SE_tf1     = input.int(50, "TF 1 Score", inline = "ema_se_tf1", group = GRP_LIB_EMA_SE_TF)
bool   lib_ema_SE_tf1_req = input.bool(false, "Required", inline = "ema_se_tf1", group = GRP_LIB_EMA_SE_TF)
int    lib_ema_SE_tf2     = input.int(50, "TF 2 Score", inline = "ema_se_tf2", group = GRP_LIB_EMA_SE_TF)
bool   lib_ema_SE_tf2_req = input.bool(false, "Required", inline = "ema_se_tf2", group = GRP_LIB_EMA_SE_TF)
int    lib_ema_SE_tf3     = input.int(50, "TF 3 Score", inline = "ema_se_tf3", group = GRP_LIB_EMA_SE_TF)
bool   lib_ema_SE_tf3_req = input.bool(false, "Required", inline = "ema_se_tf3", group = GRP_LIB_EMA_SE_TF)
int    lib_ema_SE_tf4     = input.int(0, "TF 4 Score", inline = "ema_se_tf4", group = GRP_LIB_EMA_SE_TF)
bool   lib_ema_SE_tf4_req = input.bool(false, "Required", inline = "ema_se_tf4", group = GRP_LIB_EMA_SE_TF)
int    lib_ema_SE_tf5     = input.int(0, "TF 5 Score", inline = "ema_se_tf5", group = GRP_LIB_EMA_SE_TF)
bool   lib_ema_SE_tf5_req = input.bool(false, "Required", inline = "ema_se_tf5", group = GRP_LIB_EMA_SE_TF)
int    lib_ema_SE_tf6     = input.int(0, "TF 6 Score", inline = "ema_se_tf6", group = GRP_LIB_EMA_SE_TF)
bool   lib_ema_SE_tf6_req = input.bool(false, "Required", inline = "ema_se_tf6", group = GRP_LIB_EMA_SE_TF)

string GRP_LIB_EMA_LX   = "6-1.4 EMA Stack – Long Exit"
bool   lib_ema_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_EMA_LX, inline = "ema_lx1")
string lib_ema_LX_source = input.string("S < M Cross", "", options = ["None","S > M Cross","S < M Cross","S > L Cross","S < L Cross","M > L Cross","M < L Cross"], group = GRP_LIB_EMA_LX, inline = "ema_lx1", tooltip = "Short EMA crosses below Medium EMA")
string lib_ema_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_EMA_LX, inline = "ema_lx2")
bool   lib_ema_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_EMA_LX, inline = "ema_lx2")

string GRP_LIB_EMA_SX   = "6-1.5 EMA Stack – Short Exit"
bool   lib_ema_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_EMA_SX, inline = "ema_sx1")
string lib_ema_SX_source = input.string("S > M Cross", "", options = ["None","S > M Cross","S < M Cross","S > L Cross","S < L Cross","M > L Cross","M < L Cross"], group = GRP_LIB_EMA_SX, inline = "ema_sx1", tooltip = "Short EMA crosses above Medium EMA")
string lib_ema_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_EMA_SX, inline = "ema_sx2")
bool   lib_ema_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_EMA_SX, inline = "ema_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: EMA_STACK ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY BLOCK: RVOL ██████
// GENERATOR_ID: RVOL
// SECURITY_CALLS: 6
// DEPENDENCIES: yamigushi/KevBot_TF_RVOL/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- RVOL: INPUTS ---
string GRP_LIB_RVOL      = "6-2. RVOL (Relative Volume)"
bool   lib_rvol_enabled  = input.bool(false, "Enable", group = GRP_LIB_RVOL, tooltip = "Enable RVOL interpreter for confluence analysis.")
int    lib_rvol_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_RVOL, tooltip = "0 = Hidden, 1-10 = Table row position.")
string lib_rvol_name     = input.string("RVOL", "Display Name", group = GRP_LIB_RVOL, tooltip = "Custom name shown in side table.")

// RVOL Parameters
string GRP_LIB_RVOL_PARAMS = "6-2.1 RVOL – Parameters"
int    lib_rvol_lookback  = input.int(20, "Lookback Period", minval = 1, group = GRP_LIB_RVOL_PARAMS, tooltip = "Number of bars for average volume calculation.")
float  lib_rvol_highTh    = input.float(1.5, "High Threshold", minval = 0.1, step = 0.1, group = GRP_LIB_RVOL_PARAMS, tooltip = "RVOL above this = RV+ (Elevated)")
float  lib_rvol_veryHighTh = input.float(2.0, "Very High Threshold", minval = 0.1, step = 0.1, group = GRP_LIB_RVOL_PARAMS, tooltip = "RVOL above this = RV++ (Very High)")
float  lib_rvol_extremeTh = input.float(3.0, "Extreme Threshold", minval = 0.1, step = 0.1, group = GRP_LIB_RVOL_PARAMS, tooltip = "RVOL above this = RV! (Extreme)")

// RVOL Long Entry Configuration
string GRP_LIB_RVOL_LE   = "6-2.2 RVOL – Long Entry"
bool   lib_rvol_LE_enable = input.bool(false, "Long Entry Trigger", group = GRP_LIB_RVOL_LE, inline = "rvol_le1")
string lib_rvol_LE_source = input.string("None", "", options = ["None","Vol Spike","Vol Extreme","Vol Fade"], group = GRP_LIB_RVOL_LE, inline = "rvol_le1", tooltip = "Vol Spike = RVOL crosses above high threshold")
string lib_rvol_LE_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_RVOL_LE, inline = "rvol_le2")
bool   lib_rvol_LE_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_RVOL_LE, inline = "rvol_le2")

string GRP_LIB_RVOL_LE_TF = "6-2.2.1 Long Entry – Confluences by TF"
bool   lib_rvol_LEC_enable = input.bool(false, "Long Entry Confluence", group = GRP_LIB_RVOL_LE_TF, inline = "rvol_lec1")
string lib_rvol_LEC_func   = input.string("None", "", options = ["None","RV! (Extreme)","RV++ (Very High)","RV+ (Elevated)","RV= (Normal)","RV- (Low)"], group = GRP_LIB_RVOL_LE_TF, inline = "rvol_lec1", tooltip = "Select RVOL zone condition")
bool   lib_rvol_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_RVOL_LE_TF, inline = "rvol_lec1")
int    lib_rvol_LE_tf1     = input.int(0, "TF 1 Score", inline = "rvol_le_tf1", group = GRP_LIB_RVOL_LE_TF)
bool   lib_rvol_LE_tf1_req = input.bool(false, "Required", inline = "rvol_le_tf1", group = GRP_LIB_RVOL_LE_TF)
int    lib_rvol_LE_tf2     = input.int(0, "TF 2 Score", inline = "rvol_le_tf2", group = GRP_LIB_RVOL_LE_TF)
bool   lib_rvol_LE_tf2_req = input.bool(false, "Required", inline = "rvol_le_tf2", group = GRP_LIB_RVOL_LE_TF)
int    lib_rvol_LE_tf3     = input.int(0, "TF 3 Score", inline = "rvol_le_tf3", group = GRP_LIB_RVOL_LE_TF)
bool   lib_rvol_LE_tf3_req = input.bool(false, "Required", inline = "rvol_le_tf3", group = GRP_LIB_RVOL_LE_TF)
int    lib_rvol_LE_tf4     = input.int(0, "TF 4 Score", inline = "rvol_le_tf4", group = GRP_LIB_RVOL_LE_TF)
bool   lib_rvol_LE_tf4_req = input.bool(false, "Required", inline = "rvol_le_tf4", group = GRP_LIB_RVOL_LE_TF)
int    lib_rvol_LE_tf5     = input.int(0, "TF 5 Score", inline = "rvol_le_tf5", group = GRP_LIB_RVOL_LE_TF)
bool   lib_rvol_LE_tf5_req = input.bool(false, "Required", inline = "rvol_le_tf5", group = GRP_LIB_RVOL_LE_TF)
int    lib_rvol_LE_tf6     = input.int(0, "TF 6 Score", inline = "rvol_le_tf6", group = GRP_LIB_RVOL_LE_TF)
bool   lib_rvol_LE_tf6_req = input.bool(false, "Required", inline = "rvol_le_tf6", group = GRP_LIB_RVOL_LE_TF)

// RVOL Short Entry Configuration
string GRP_LIB_RVOL_SE   = "6-2.3 RVOL – Short Entry"
bool   lib_rvol_SE_enable = input.bool(false, "Short Entry Trigger", group = GRP_LIB_RVOL_SE, inline = "rvol_se1")
string lib_rvol_SE_source = input.string("None", "", options = ["None","Vol Spike","Vol Extreme","Vol Fade"], group = GRP_LIB_RVOL_SE, inline = "rvol_se1", tooltip = "Vol Fade = RVOL crosses below 1.0")
string lib_rvol_SE_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_RVOL_SE, inline = "rvol_se2")
bool   lib_rvol_SE_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_RVOL_SE, inline = "rvol_se2")

string GRP_LIB_RVOL_SE_TF = "6-2.3.1 Short Entry – Confluences by TF"
bool   lib_rvol_SEC_enable = input.bool(false, "Short Entry Confluence", group = GRP_LIB_RVOL_SE_TF, inline = "rvol_sec1")
string lib_rvol_SEC_func   = input.string("None", "", options = ["None","RV! (Extreme)","RV++ (Very High)","RV+ (Elevated)","RV= (Normal)","RV- (Low)"], group = GRP_LIB_RVOL_SE_TF, inline = "rvol_sec1")
bool   lib_rvol_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_RVOL_SE_TF, inline = "rvol_sec1")
int    lib_rvol_SE_tf1     = input.int(0, "TF 1 Score", inline = "rvol_se_tf1", group = GRP_LIB_RVOL_SE_TF)
bool   lib_rvol_SE_tf1_req = input.bool(false, "Required", inline = "rvol_se_tf1", group = GRP_LIB_RVOL_SE_TF)
int    lib_rvol_SE_tf2     = input.int(0, "TF 2 Score", inline = "rvol_se_tf2", group = GRP_LIB_RVOL_SE_TF)
bool   lib_rvol_SE_tf2_req = input.bool(false, "Required", inline = "rvol_se_tf2", group = GRP_LIB_RVOL_SE_TF)
int    lib_rvol_SE_tf3     = input.int(0, "TF 3 Score", inline = "rvol_se_tf3", group = GRP_LIB_RVOL_SE_TF)
bool   lib_rvol_SE_tf3_req = input.bool(false, "Required", inline = "rvol_se_tf3", group = GRP_LIB_RVOL_SE_TF)
int    lib_rvol_SE_tf4     = input.int(0, "TF 4 Score", inline = "rvol_se_tf4", group = GRP_LIB_RVOL_SE_TF)
bool   lib_rvol_SE_tf4_req = input.bool(false, "Required", inline = "rvol_se_tf4", group = GRP_LIB_RVOL_SE_TF)
int    lib_rvol_SE_tf5     = input.int(0, "TF 5 Score", inline = "rvol_se_tf5", group = GRP_LIB_RVOL_SE_TF)
bool   lib_rvol_SE_tf5_req = input.bool(false, "Required", inline = "rvol_se_tf5", group = GRP_LIB_RVOL_SE_TF)
int    lib_rvol_SE_tf6     = input.int(0, "TF 6 Score", inline = "rvol_se_tf6", group = GRP_LIB_RVOL_SE_TF)
bool   lib_rvol_SE_tf6_req = input.bool(false, "Required", inline = "rvol_se_tf6", group = GRP_LIB_RVOL_SE_TF)

// RVOL Long Exit Configuration
string GRP_LIB_RVOL_LX   = "6-2.4 RVOL – Long Exit"
bool   lib_rvol_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_RVOL_LX, inline = "rvol_lx1")
string lib_rvol_LX_source = input.string("None", "", options = ["None","Vol Spike","Vol Extreme","Vol Fade"], group = GRP_LIB_RVOL_LX, inline = "rvol_lx1")
string lib_rvol_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_RVOL_LX, inline = "rvol_lx2")
bool   lib_rvol_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_RVOL_LX, inline = "rvol_lx2")

// RVOL Short Exit Configuration
string GRP_LIB_RVOL_SX   = "6-2.5 RVOL – Short Exit"
bool   lib_rvol_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_RVOL_SX, inline = "rvol_sx1")
string lib_rvol_SX_source = input.string("None", "", options = ["None","Vol Spike","Vol Extreme","Vol Fade"], group = GRP_LIB_RVOL_SX, inline = "rvol_sx1")
string lib_rvol_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_RVOL_SX, inline = "rvol_sx2")
bool   lib_rvol_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_RVOL_SX, inline = "rvol_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: RVOL ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY BLOCK: UT_BOT ██████
// GENERATOR_ID: UT_BOT
// SECURITY_CALLS: 7
// DEPENDENCIES: yamigushi/KevBot_TF_UTBot/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- UT_BOT: INPUTS ---
string GRP_LIB_UTBOT      = "6-3. UT Bot"
bool   lib_utbot_enabled  = input.bool(false, "Enable", group = GRP_LIB_UTBOT, tooltip = "Enable UT Bot ATR trailing stop interpreter.")
int    lib_utbot_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_UTBOT, tooltip = "0 = Hidden, 1-10 = Table row position.")
string lib_utbot_name     = input.string("UT Bot", "Display Name", group = GRP_LIB_UTBOT, tooltip = "Custom name shown in side table.")

// UT Bot Parameters
string GRP_LIB_UTBOT_PARAMS = "6-3.1 UT Bot – Parameters"
float  lib_utbot_keyval   = input.float(1.0, "Key Value (ATR Mult)", minval = 0.1, step = 0.1, group = GRP_LIB_UTBOT_PARAMS, tooltip = "ATR multiplier for trailing stop sensitivity.")
int    lib_utbot_atrlen   = input.int(10, "ATR Period", minval = 1, group = GRP_LIB_UTBOT_PARAMS, tooltip = "Lookback period for ATR calculation.")
bool   lib_utbot_useHA    = input.bool(false, "Use Heikin Ashi", group = GRP_LIB_UTBOT_PARAMS, tooltip = "Use Heikin Ashi candles for source data.")

// UT Bot Entry/Exit Configuration
string GRP_LIB_UTBOT_LE   = "6-3.2 UT Bot – Long Entry"
bool   lib_utbot_LE_enable = input.bool(true, "Long Entry Trigger", group = GRP_LIB_UTBOT_LE, inline = "utbot_le1")
string lib_utbot_LE_source = input.string("Buy", "", options = ["None","Buy","Sell"], group = GRP_LIB_UTBOT_LE, inline = "utbot_le1", tooltip = "Buy = Price crosses above trailing stop")
string lib_utbot_LE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_UTBOT_LE, inline = "utbot_le2")
bool   lib_utbot_LE_bull   = input.bool(true, "Bullish Label", group = GRP_LIB_UTBOT_LE, inline = "utbot_le2")

string GRP_LIB_UTBOT_LE_TF = "6-3.2.1 Long Entry – Confluences by TF"
bool   lib_utbot_LEC_enable = input.bool(true, "Long Entry Confluence", group = GRP_LIB_UTBOT_LE_TF, inline = "utbot_lec1")
string lib_utbot_LEC_func   = input.string("Bull", "", options = ["None","Bull","Bear"], group = GRP_LIB_UTBOT_LE_TF, inline = "utbot_lec1", tooltip = "Bull = Price above trailing stop")
bool   lib_utbot_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_UTBOT_LE_TF, inline = "utbot_lec1")
int    lib_utbot_LE_tf1     = input.int(50, "TF 1 Score", inline = "utbot_le_tf1", group = GRP_LIB_UTBOT_LE_TF)
bool   lib_utbot_LE_tf1_req = input.bool(false, "Required", inline = "utbot_le_tf1", group = GRP_LIB_UTBOT_LE_TF)
int    lib_utbot_LE_tf2     = input.int(50, "TF 2 Score", inline = "utbot_le_tf2", group = GRP_LIB_UTBOT_LE_TF)
bool   lib_utbot_LE_tf2_req = input.bool(false, "Required", inline = "utbot_le_tf2", group = GRP_LIB_UTBOT_LE_TF)
int    lib_utbot_LE_tf3     = input.int(50, "TF 3 Score", inline = "utbot_le_tf3", group = GRP_LIB_UTBOT_LE_TF)
bool   lib_utbot_LE_tf3_req = input.bool(false, "Required", inline = "utbot_le_tf3", group = GRP_LIB_UTBOT_LE_TF)
int    lib_utbot_LE_tf4     = input.int(0, "TF 4 Score", inline = "utbot_le_tf4", group = GRP_LIB_UTBOT_LE_TF)
bool   lib_utbot_LE_tf4_req = input.bool(false, "Required", inline = "utbot_le_tf4", group = GRP_LIB_UTBOT_LE_TF)
int    lib_utbot_LE_tf5     = input.int(0, "TF 5 Score", inline = "utbot_le_tf5", group = GRP_LIB_UTBOT_LE_TF)
bool   lib_utbot_LE_tf5_req = input.bool(false, "Required", inline = "utbot_le_tf5", group = GRP_LIB_UTBOT_LE_TF)
int    lib_utbot_LE_tf6     = input.int(0, "TF 6 Score", inline = "utbot_le_tf6", group = GRP_LIB_UTBOT_LE_TF)
bool   lib_utbot_LE_tf6_req = input.bool(false, "Required", inline = "utbot_le_tf6", group = GRP_LIB_UTBOT_LE_TF)

string GRP_LIB_UTBOT_SE   = "6-3.3 UT Bot – Short Entry"
bool   lib_utbot_SE_enable = input.bool(true, "Short Entry Trigger", group = GRP_LIB_UTBOT_SE, inline = "utbot_se1")
string lib_utbot_SE_source = input.string("Sell", "", options = ["None","Buy","Sell"], group = GRP_LIB_UTBOT_SE, inline = "utbot_se1", tooltip = "Sell = Price crosses below trailing stop")
string lib_utbot_SE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_UTBOT_SE, inline = "utbot_se2")
bool   lib_utbot_SE_bear   = input.bool(true, "Bearish Label", group = GRP_LIB_UTBOT_SE, inline = "utbot_se2")

string GRP_LIB_UTBOT_SE_TF = "6-3.3.1 Short Entry – Confluences by TF"
bool   lib_utbot_SEC_enable = input.bool(true, "Short Entry Confluence", group = GRP_LIB_UTBOT_SE_TF, inline = "utbot_sec1")
string lib_utbot_SEC_func   = input.string("Bear", "", options = ["None","Bull","Bear"], group = GRP_LIB_UTBOT_SE_TF, inline = "utbot_sec1", tooltip = "Bear = Price below trailing stop")
bool   lib_utbot_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_UTBOT_SE_TF, inline = "utbot_sec1")
int    lib_utbot_SE_tf1     = input.int(50, "TF 1 Score", inline = "utbot_se_tf1", group = GRP_LIB_UTBOT_SE_TF)
bool   lib_utbot_SE_tf1_req = input.bool(false, "Required", inline = "utbot_se_tf1", group = GRP_LIB_UTBOT_SE_TF)
int    lib_utbot_SE_tf2     = input.int(50, "TF 2 Score", inline = "utbot_se_tf2", group = GRP_LIB_UTBOT_SE_TF)
bool   lib_utbot_SE_tf2_req = input.bool(false, "Required", inline = "utbot_se_tf2", group = GRP_LIB_UTBOT_SE_TF)
int    lib_utbot_SE_tf3     = input.int(50, "TF 3 Score", inline = "utbot_se_tf3", group = GRP_LIB_UTBOT_SE_TF)
bool   lib_utbot_SE_tf3_req = input.bool(false, "Required", inline = "utbot_se_tf3", group = GRP_LIB_UTBOT_SE_TF)
int    lib_utbot_SE_tf4     = input.int(0, "TF 4 Score", inline = "utbot_se_tf4", group = GRP_LIB_UTBOT_SE_TF)
bool   lib_utbot_SE_tf4_req = input.bool(false, "Required", inline = "utbot_se_tf4", group = GRP_LIB_UTBOT_SE_TF)
int    lib_utbot_SE_tf5     = input.int(0, "TF 5 Score", inline = "utbot_se_tf5", group = GRP_LIB_UTBOT_SE_TF)
bool   lib_utbot_SE_tf5_req = input.bool(false, "Required", inline = "utbot_se_tf5", group = GRP_LIB_UTBOT_SE_TF)
int    lib_utbot_SE_tf6     = input.int(0, "TF 6 Score", inline = "utbot_se_tf6", group = GRP_LIB_UTBOT_SE_TF)
bool   lib_utbot_SE_tf6_req = input.bool(false, "Required", inline = "utbot_se_tf6", group = GRP_LIB_UTBOT_SE_TF)

string GRP_LIB_UTBOT_LX   = "6-3.4 UT Bot – Long Exit"
bool   lib_utbot_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_UTBOT_LX, inline = "utbot_lx1")
string lib_utbot_LX_source = input.string("Sell", "", options = ["None","Buy","Sell"], group = GRP_LIB_UTBOT_LX, inline = "utbot_lx1")
string lib_utbot_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_UTBOT_LX, inline = "utbot_lx2")
bool   lib_utbot_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_UTBOT_LX, inline = "utbot_lx2")

string GRP_LIB_UTBOT_SX   = "6-3.5 UT Bot – Short Exit"
bool   lib_utbot_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_UTBOT_SX, inline = "utbot_sx1")
string lib_utbot_SX_source = input.string("Buy", "", options = ["None","Buy","Sell"], group = GRP_LIB_UTBOT_SX, inline = "utbot_sx1")
string lib_utbot_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_UTBOT_SX, inline = "utbot_sx2")
bool   lib_utbot_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_UTBOT_SX, inline = "utbot_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: UT_BOT ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY BLOCK: SWING123 ██████
// GENERATOR_ID: SWING123
// SECURITY_CALLS: 24
// DEPENDENCIES: yamigushi/KevBot_TF_Swing123/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- SWING123: INPUTS ---
string GRP_LIB_SWING      = "6-4. Swing 1-2-3"
bool   lib_swing_enabled  = input.bool(false, "Enable", group = GRP_LIB_SWING, tooltip = "Enable Swing 1-2-3 reversal pattern interpreter. WARNING: Uses 24 security calls!")
int    lib_swing_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_SWING, tooltip = "0 = Hidden, 1-10 = Table row position.")
string lib_swing_name     = input.string("Swing 123", "Display Name", group = GRP_LIB_SWING, tooltip = "Custom name shown in side table.")

// Swing 123 has no parameters - pattern is fixed

// Swing 123 Entry/Exit Configuration
string GRP_LIB_SWING_LE   = "6-4.2 Swing 123 – Long Entry"
bool   lib_swing_LE_enable = input.bool(true, "Long Entry Trigger", group = GRP_LIB_SWING_LE, inline = "swing_le1")
string lib_swing_LE_source = input.string("BC3", "", options = ["None","BC2","BC3","XC2","XC3"], group = GRP_LIB_SWING_LE, inline = "swing_le1", tooltip = "BC3 = Bullish Candle 3 confirmation")
string lib_swing_LE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_SWING_LE, inline = "swing_le2")
bool   lib_swing_LE_bull   = input.bool(true, "Bullish Label", group = GRP_LIB_SWING_LE, inline = "swing_le2")

string GRP_LIB_SWING_LE_TF = "6-4.2.1 Long Entry – Confluences by TF"
bool   lib_swing_LEC_enable = input.bool(true, "Long Entry Confluence", group = GRP_LIB_SWING_LE_TF, inline = "swing_lec1")
string lib_swing_LEC_func   = input.string("B↑", "", options = ["None","BC2","BC3","XC2","XC3","B↑","X↓"], group = GRP_LIB_SWING_LE_TF, inline = "swing_lec1", tooltip = "B↑ = Recent bullish setup")
bool   lib_swing_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_SWING_LE_TF, inline = "swing_lec1")
int    lib_swing_LE_tf1     = input.int(50, "TF 1 Score", inline = "swing_le_tf1", group = GRP_LIB_SWING_LE_TF)
bool   lib_swing_LE_tf1_req = input.bool(false, "Required", inline = "swing_le_tf1", group = GRP_LIB_SWING_LE_TF)
int    lib_swing_LE_tf2     = input.int(50, "TF 2 Score", inline = "swing_le_tf2", group = GRP_LIB_SWING_LE_TF)
bool   lib_swing_LE_tf2_req = input.bool(false, "Required", inline = "swing_le_tf2", group = GRP_LIB_SWING_LE_TF)
int    lib_swing_LE_tf3     = input.int(50, "TF 3 Score", inline = "swing_le_tf3", group = GRP_LIB_SWING_LE_TF)
bool   lib_swing_LE_tf3_req = input.bool(false, "Required", inline = "swing_le_tf3", group = GRP_LIB_SWING_LE_TF)
int    lib_swing_LE_tf4     = input.int(0, "TF 4 Score", inline = "swing_le_tf4", group = GRP_LIB_SWING_LE_TF)
bool   lib_swing_LE_tf4_req = input.bool(false, "Required", inline = "swing_le_tf4", group = GRP_LIB_SWING_LE_TF)
int    lib_swing_LE_tf5     = input.int(0, "TF 5 Score", inline = "swing_le_tf5", group = GRP_LIB_SWING_LE_TF)
bool   lib_swing_LE_tf5_req = input.bool(false, "Required", inline = "swing_le_tf5", group = GRP_LIB_SWING_LE_TF)
int    lib_swing_LE_tf6     = input.int(0, "TF 6 Score", inline = "swing_le_tf6", group = GRP_LIB_SWING_LE_TF)
bool   lib_swing_LE_tf6_req = input.bool(false, "Required", inline = "swing_le_tf6", group = GRP_LIB_SWING_LE_TF)

string GRP_LIB_SWING_SE   = "6-4.3 Swing 123 – Short Entry"
bool   lib_swing_SE_enable = input.bool(true, "Short Entry Trigger", group = GRP_LIB_SWING_SE, inline = "swing_se1")
string lib_swing_SE_source = input.string("XC3", "", options = ["None","BC2","BC3","XC2","XC3"], group = GRP_LIB_SWING_SE, inline = "swing_se1", tooltip = "XC3 = Bearish Candle 3 confirmation")
string lib_swing_SE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_SWING_SE, inline = "swing_se2")
bool   lib_swing_SE_bear   = input.bool(true, "Bearish Label", group = GRP_LIB_SWING_SE, inline = "swing_se2")

string GRP_LIB_SWING_SE_TF = "6-4.3.1 Short Entry – Confluences by TF"
bool   lib_swing_SEC_enable = input.bool(true, "Short Entry Confluence", group = GRP_LIB_SWING_SE_TF, inline = "swing_sec1")
string lib_swing_SEC_func   = input.string("X↓", "", options = ["None","BC2","BC3","XC2","XC3","B↑","X↓"], group = GRP_LIB_SWING_SE_TF, inline = "swing_sec1", tooltip = "X↓ = Recent bearish setup")
bool   lib_swing_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_SWING_SE_TF, inline = "swing_sec1")
int    lib_swing_SE_tf1     = input.int(50, "TF 1 Score", inline = "swing_se_tf1", group = GRP_LIB_SWING_SE_TF)
bool   lib_swing_SE_tf1_req = input.bool(false, "Required", inline = "swing_se_tf1", group = GRP_LIB_SWING_SE_TF)
int    lib_swing_SE_tf2     = input.int(50, "TF 2 Score", inline = "swing_se_tf2", group = GRP_LIB_SWING_SE_TF)
bool   lib_swing_SE_tf2_req = input.bool(false, "Required", inline = "swing_se_tf2", group = GRP_LIB_SWING_SE_TF)
int    lib_swing_SE_tf3     = input.int(50, "TF 3 Score", inline = "swing_se_tf3", group = GRP_LIB_SWING_SE_TF)
bool   lib_swing_SE_tf3_req = input.bool(false, "Required", inline = "swing_se_tf3", group = GRP_LIB_SWING_SE_TF)
int    lib_swing_SE_tf4     = input.int(0, "TF 4 Score", inline = "swing_se_tf4", group = GRP_LIB_SWING_SE_TF)
bool   lib_swing_SE_tf4_req = input.bool(false, "Required", inline = "swing_se_tf4", group = GRP_LIB_SWING_SE_TF)
int    lib_swing_SE_tf5     = input.int(0, "TF 5 Score", inline = "swing_se_tf5", group = GRP_LIB_SWING_SE_TF)
bool   lib_swing_SE_tf5_req = input.bool(false, "Required", inline = "swing_se_tf5", group = GRP_LIB_SWING_SE_TF)
int    lib_swing_SE_tf6     = input.int(0, "TF 6 Score", inline = "swing_se_tf6", group = GRP_LIB_SWING_SE_TF)
bool   lib_swing_SE_tf6_req = input.bool(false, "Required", inline = "swing_se_tf6", group = GRP_LIB_SWING_SE_TF)

string GRP_LIB_SWING_LX   = "6-4.4 Swing 123 – Long Exit"
bool   lib_swing_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_SWING_LX, inline = "swing_lx1")
string lib_swing_LX_source = input.string("XC3", "", options = ["None","BC2","BC3","XC2","XC3"], group = GRP_LIB_SWING_LX, inline = "swing_lx1")
string lib_swing_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_SWING_LX, inline = "swing_lx2")
bool   lib_swing_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_SWING_LX, inline = "swing_lx2")

string GRP_LIB_SWING_SX   = "6-4.5 Swing 123 – Short Exit"
bool   lib_swing_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_SWING_SX, inline = "swing_sx1")
string lib_swing_SX_source = input.string("BC3", "", options = ["None","BC2","BC3","XC2","XC3"], group = GRP_LIB_SWING_SX, inline = "swing_sx1")
string lib_swing_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_SWING_SX, inline = "swing_sx2")
bool   lib_swing_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_SWING_SX, inline = "swing_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: SWING123 ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY BLOCK: MACD_LINE ██████
// GENERATOR_ID: MACD_LINE
// SECURITY_CALLS: 6
// DEPENDENCIES: yamigushi/KevBot_TF_MACD_Line/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- MACD_LINE: INPUTS ---
string GRP_LIB_MACDL      = "6-5. MACD Line"
bool   lib_macdl_enabled  = input.bool(false, "Enable", group = GRP_LIB_MACDL, tooltip = "Enable MACD Line with zero context interpreter.")
int    lib_macdl_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_MACDL, tooltip = "0 = Hidden, 1-10 = Table row position.")
string lib_macdl_name     = input.string("MACD Line", "Display Name", group = GRP_LIB_MACDL, tooltip = "Custom name shown in side table.")

// MACD Line Parameters
string GRP_LIB_MACDL_PARAMS = "6-5.1 MACD Line – Parameters"
int    lib_macdl_fast     = input.int(12, "Fast Length", minval = 1, group = GRP_LIB_MACDL_PARAMS)
int    lib_macdl_slow     = input.int(26, "Slow Length", minval = 1, group = GRP_LIB_MACDL_PARAMS)
int    lib_macdl_signal   = input.int(9, "Signal Length", minval = 1, group = GRP_LIB_MACDL_PARAMS)

// MACD Line Entry/Exit Configuration
string GRP_LIB_MACDL_LE   = "6-5.2 MACD Line – Long Entry"
bool   lib_macdl_LE_enable = input.bool(true, "Long Entry Trigger", group = GRP_LIB_MACDL_LE, inline = "macdl_le1")
string lib_macdl_LE_source = input.string("Bullish Cross", "", options = ["None","Bullish Cross","Bearish Cross","Zero Cross Up","Zero Cross Down"], group = GRP_LIB_MACDL_LE, inline = "macdl_le1")
string lib_macdl_LE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDL_LE, inline = "macdl_le2")
bool   lib_macdl_LE_bull   = input.bool(true, "Bullish Label", group = GRP_LIB_MACDL_LE, inline = "macdl_le2")

string GRP_LIB_MACDL_LE_TF = "6-5.2.1 Long Entry – Confluences by TF"
bool   lib_macdl_LEC_enable = input.bool(true, "Long Entry Confluence", group = GRP_LIB_MACDL_LE_TF, inline = "macdl_lec1")
string lib_macdl_LEC_func   = input.string("M>S+", "", options = ["None","M>S+","M>S-","M<S-","M<S+"], group = GRP_LIB_MACDL_LE_TF, inline = "macdl_lec1", tooltip = "M>S+ = MACD > Signal AND MACD > 0")
bool   lib_macdl_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_MACDL_LE_TF, inline = "macdl_lec1")
int    lib_macdl_LE_tf1     = input.int(50, "TF 1 Score", inline = "macdl_le_tf1", group = GRP_LIB_MACDL_LE_TF)
bool   lib_macdl_LE_tf1_req = input.bool(false, "Required", inline = "macdl_le_tf1", group = GRP_LIB_MACDL_LE_TF)
int    lib_macdl_LE_tf2     = input.int(50, "TF 2 Score", inline = "macdl_le_tf2", group = GRP_LIB_MACDL_LE_TF)
bool   lib_macdl_LE_tf2_req = input.bool(false, "Required", inline = "macdl_le_tf2", group = GRP_LIB_MACDL_LE_TF)
int    lib_macdl_LE_tf3     = input.int(50, "TF 3 Score", inline = "macdl_le_tf3", group = GRP_LIB_MACDL_LE_TF)
bool   lib_macdl_LE_tf3_req = input.bool(false, "Required", inline = "macdl_le_tf3", group = GRP_LIB_MACDL_LE_TF)
int    lib_macdl_LE_tf4     = input.int(0, "TF 4 Score", inline = "macdl_le_tf4", group = GRP_LIB_MACDL_LE_TF)
bool   lib_macdl_LE_tf4_req = input.bool(false, "Required", inline = "macdl_le_tf4", group = GRP_LIB_MACDL_LE_TF)
int    lib_macdl_LE_tf5     = input.int(0, "TF 5 Score", inline = "macdl_le_tf5", group = GRP_LIB_MACDL_LE_TF)
bool   lib_macdl_LE_tf5_req = input.bool(false, "Required", inline = "macdl_le_tf5", group = GRP_LIB_MACDL_LE_TF)
int    lib_macdl_LE_tf6     = input.int(0, "TF 6 Score", inline = "macdl_le_tf6", group = GRP_LIB_MACDL_LE_TF)
bool   lib_macdl_LE_tf6_req = input.bool(false, "Required", inline = "macdl_le_tf6", group = GRP_LIB_MACDL_LE_TF)

string GRP_LIB_MACDL_SE   = "6-5.3 MACD Line – Short Entry"
bool   lib_macdl_SE_enable = input.bool(true, "Short Entry Trigger", group = GRP_LIB_MACDL_SE, inline = "macdl_se1")
string lib_macdl_SE_source = input.string("Bearish Cross", "", options = ["None","Bullish Cross","Bearish Cross","Zero Cross Up","Zero Cross Down"], group = GRP_LIB_MACDL_SE, inline = "macdl_se1")
string lib_macdl_SE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDL_SE, inline = "macdl_se2")
bool   lib_macdl_SE_bear   = input.bool(true, "Bearish Label", group = GRP_LIB_MACDL_SE, inline = "macdl_se2")

string GRP_LIB_MACDL_SE_TF = "6-5.3.1 Short Entry – Confluences by TF"
bool   lib_macdl_SEC_enable = input.bool(true, "Short Entry Confluence", group = GRP_LIB_MACDL_SE_TF, inline = "macdl_sec1")
string lib_macdl_SEC_func   = input.string("M<S-", "", options = ["None","M>S+","M>S-","M<S-","M<S+"], group = GRP_LIB_MACDL_SE_TF, inline = "macdl_sec1", tooltip = "M<S- = MACD < Signal AND MACD < 0")
bool   lib_macdl_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_MACDL_SE_TF, inline = "macdl_sec1")
int    lib_macdl_SE_tf1     = input.int(50, "TF 1 Score", inline = "macdl_se_tf1", group = GRP_LIB_MACDL_SE_TF)
bool   lib_macdl_SE_tf1_req = input.bool(false, "Required", inline = "macdl_se_tf1", group = GRP_LIB_MACDL_SE_TF)
int    lib_macdl_SE_tf2     = input.int(50, "TF 2 Score", inline = "macdl_se_tf2", group = GRP_LIB_MACDL_SE_TF)
bool   lib_macdl_SE_tf2_req = input.bool(false, "Required", inline = "macdl_se_tf2", group = GRP_LIB_MACDL_SE_TF)
int    lib_macdl_SE_tf3     = input.int(50, "TF 3 Score", inline = "macdl_se_tf3", group = GRP_LIB_MACDL_SE_TF)
bool   lib_macdl_SE_tf3_req = input.bool(false, "Required", inline = "macdl_se_tf3", group = GRP_LIB_MACDL_SE_TF)
int    lib_macdl_SE_tf4     = input.int(0, "TF 4 Score", inline = "macdl_se_tf4", group = GRP_LIB_MACDL_SE_TF)
bool   lib_macdl_SE_tf4_req = input.bool(false, "Required", inline = "macdl_se_tf4", group = GRP_LIB_MACDL_SE_TF)
int    lib_macdl_SE_tf5     = input.int(0, "TF 5 Score", inline = "macdl_se_tf5", group = GRP_LIB_MACDL_SE_TF)
bool   lib_macdl_SE_tf5_req = input.bool(false, "Required", inline = "macdl_se_tf5", group = GRP_LIB_MACDL_SE_TF)
int    lib_macdl_SE_tf6     = input.int(0, "TF 6 Score", inline = "macdl_se_tf6", group = GRP_LIB_MACDL_SE_TF)
bool   lib_macdl_SE_tf6_req = input.bool(false, "Required", inline = "macdl_se_tf6", group = GRP_LIB_MACDL_SE_TF)

string GRP_LIB_MACDL_LX   = "6-5.4 MACD Line – Long Exit"
bool   lib_macdl_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_MACDL_LX, inline = "macdl_lx1")
string lib_macdl_LX_source = input.string("Bearish Cross", "", options = ["None","Bullish Cross","Bearish Cross","Zero Cross Up","Zero Cross Down"], group = GRP_LIB_MACDL_LX, inline = "macdl_lx1")
string lib_macdl_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDL_LX, inline = "macdl_lx2")
bool   lib_macdl_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_MACDL_LX, inline = "macdl_lx2")

string GRP_LIB_MACDL_SX   = "6-5.5 MACD Line – Short Exit"
bool   lib_macdl_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_MACDL_SX, inline = "macdl_sx1")
string lib_macdl_SX_source = input.string("Bullish Cross", "", options = ["None","Bullish Cross","Bearish Cross","Zero Cross Up","Zero Cross Down"], group = GRP_LIB_MACDL_SX, inline = "macdl_sx1")
string lib_macdl_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDL_SX, inline = "macdl_sx2")
bool   lib_macdl_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_MACDL_SX, inline = "macdl_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: MACD_LINE ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY BLOCK: MACD_HISTOGRAM ██████
// GENERATOR_ID: MACD_HISTOGRAM
// SECURITY_CALLS: 6
// DEPENDENCIES: yamigushi/KevBot_TF_MACD_Histogram/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- MACD_HISTOGRAM: INPUTS ---
string GRP_LIB_MACDH      = "6-6. MACD Histogram"
bool   lib_macdh_enabled  = input.bool(false, "Enable", group = GRP_LIB_MACDH, tooltip = "Enable MACD Histogram momentum interpreter.")
int    lib_macdh_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_MACDH, tooltip = "0 = Hidden, 1-10 = Table row position.")
string lib_macdh_name     = input.string("MACD Hist", "Display Name", group = GRP_LIB_MACDH, tooltip = "Custom name shown in side table.")

// MACD Histogram Parameters
string GRP_LIB_MACDH_PARAMS = "6-6.1 MACD Histogram – Parameters"
int    lib_macdh_fast     = input.int(12, "Fast Length", minval = 1, group = GRP_LIB_MACDH_PARAMS)
int    lib_macdh_slow     = input.int(26, "Slow Length", minval = 1, group = GRP_LIB_MACDH_PARAMS)
int    lib_macdh_signal   = input.int(9, "Signal Length", minval = 1, group = GRP_LIB_MACDH_PARAMS)

// MACD Histogram Entry/Exit Configuration
string GRP_LIB_MACDH_LE   = "6-6.2 MACD Histogram – Long Entry"
bool   lib_macdh_LE_enable = input.bool(true, "Long Entry Trigger", group = GRP_LIB_MACDH_LE, inline = "macdh_le1")
string lib_macdh_LE_source = input.string("Flip Bullish", "", options = ["None","Flip Bullish","Flip Bearish","Shift Up","Shift Down"], group = GRP_LIB_MACDH_LE, inline = "macdh_le1")
string lib_macdh_LE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDH_LE, inline = "macdh_le2")
bool   lib_macdh_LE_bull   = input.bool(true, "Bullish Label", group = GRP_LIB_MACDH_LE, inline = "macdh_le2")

string GRP_LIB_MACDH_LE_TF = "6-6.2.1 Long Entry – Confluences by TF"
bool   lib_macdh_LEC_enable = input.bool(true, "Long Entry Confluence", group = GRP_LIB_MACDH_LE_TF, inline = "macdh_lec1")
string lib_macdh_LEC_func   = input.string("H+↑", "", options = ["None","H+↑","H+↓","H-↓","H-↑"], group = GRP_LIB_MACDH_LE_TF, inline = "macdh_lec1", tooltip = "H+↑ = Histogram positive and rising")
bool   lib_macdh_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_MACDH_LE_TF, inline = "macdh_lec1")
int    lib_macdh_LE_tf1     = input.int(50, "TF 1 Score", inline = "macdh_le_tf1", group = GRP_LIB_MACDH_LE_TF)
bool   lib_macdh_LE_tf1_req = input.bool(false, "Required", inline = "macdh_le_tf1", group = GRP_LIB_MACDH_LE_TF)
int    lib_macdh_LE_tf2     = input.int(50, "TF 2 Score", inline = "macdh_le_tf2", group = GRP_LIB_MACDH_LE_TF)
bool   lib_macdh_LE_tf2_req = input.bool(false, "Required", inline = "macdh_le_tf2", group = GRP_LIB_MACDH_LE_TF)
int    lib_macdh_LE_tf3     = input.int(50, "TF 3 Score", inline = "macdh_le_tf3", group = GRP_LIB_MACDH_LE_TF)
bool   lib_macdh_LE_tf3_req = input.bool(false, "Required", inline = "macdh_le_tf3", group = GRP_LIB_MACDH_LE_TF)
int    lib_macdh_LE_tf4     = input.int(0, "TF 4 Score", inline = "macdh_le_tf4", group = GRP_LIB_MACDH_LE_TF)
bool   lib_macdh_LE_tf4_req = input.bool(false, "Required", inline = "macdh_le_tf4", group = GRP_LIB_MACDH_LE_TF)
int    lib_macdh_LE_tf5     = input.int(0, "TF 5 Score", inline = "macdh_le_tf5", group = GRP_LIB_MACDH_LE_TF)
bool   lib_macdh_LE_tf5_req = input.bool(false, "Required", inline = "macdh_le_tf5", group = GRP_LIB_MACDH_LE_TF)
int    lib_macdh_LE_tf6     = input.int(0, "TF 6 Score", inline = "macdh_le_tf6", group = GRP_LIB_MACDH_LE_TF)
bool   lib_macdh_LE_tf6_req = input.bool(false, "Required", inline = "macdh_le_tf6", group = GRP_LIB_MACDH_LE_TF)

string GRP_LIB_MACDH_SE   = "6-6.3 MACD Histogram – Short Entry"
bool   lib_macdh_SE_enable = input.bool(true, "Short Entry Trigger", group = GRP_LIB_MACDH_SE, inline = "macdh_se1")
string lib_macdh_SE_source = input.string("Flip Bearish", "", options = ["None","Flip Bullish","Flip Bearish","Shift Up","Shift Down"], group = GRP_LIB_MACDH_SE, inline = "macdh_se1")
string lib_macdh_SE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDH_SE, inline = "macdh_se2")
bool   lib_macdh_SE_bear   = input.bool(true, "Bearish Label", group = GRP_LIB_MACDH_SE, inline = "macdh_se2")

string GRP_LIB_MACDH_SE_TF = "6-6.3.1 Short Entry – Confluences by TF"
bool   lib_macdh_SEC_enable = input.bool(true, "Short Entry Confluence", group = GRP_LIB_MACDH_SE_TF, inline = "macdh_sec1")
string lib_macdh_SEC_func   = input.string("H-↓", "", options = ["None","H+↑","H+↓","H-↓","H-↑"], group = GRP_LIB_MACDH_SE_TF, inline = "macdh_sec1", tooltip = "H-↓ = Histogram negative and falling")
bool   lib_macdh_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_MACDH_SE_TF, inline = "macdh_sec1")
int    lib_macdh_SE_tf1     = input.int(50, "TF 1 Score", inline = "macdh_se_tf1", group = GRP_LIB_MACDH_SE_TF)
bool   lib_macdh_SE_tf1_req = input.bool(false, "Required", inline = "macdh_se_tf1", group = GRP_LIB_MACDH_SE_TF)
int    lib_macdh_SE_tf2     = input.int(50, "TF 2 Score", inline = "macdh_se_tf2", group = GRP_LIB_MACDH_SE_TF)
bool   lib_macdh_SE_tf2_req = input.bool(false, "Required", inline = "macdh_se_tf2", group = GRP_LIB_MACDH_SE_TF)
int    lib_macdh_SE_tf3     = input.int(50, "TF 3 Score", inline = "macdh_se_tf3", group = GRP_LIB_MACDH_SE_TF)
bool   lib_macdh_SE_tf3_req = input.bool(false, "Required", inline = "macdh_se_tf3", group = GRP_LIB_MACDH_SE_TF)
int    lib_macdh_SE_tf4     = input.int(0, "TF 4 Score", inline = "macdh_se_tf4", group = GRP_LIB_MACDH_SE_TF)
bool   lib_macdh_SE_tf4_req = input.bool(false, "Required", inline = "macdh_se_tf4", group = GRP_LIB_MACDH_SE_TF)
int    lib_macdh_SE_tf5     = input.int(0, "TF 5 Score", inline = "macdh_se_tf5", group = GRP_LIB_MACDH_SE_TF)
bool   lib_macdh_SE_tf5_req = input.bool(false, "Required", inline = "macdh_se_tf5", group = GRP_LIB_MACDH_SE_TF)
int    lib_macdh_SE_tf6     = input.int(0, "TF 6 Score", inline = "macdh_se_tf6", group = GRP_LIB_MACDH_SE_TF)
bool   lib_macdh_SE_tf6_req = input.bool(false, "Required", inline = "macdh_se_tf6", group = GRP_LIB_MACDH_SE_TF)

string GRP_LIB_MACDH_LX   = "6-6.4 MACD Histogram – Long Exit"
bool   lib_macdh_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_MACDH_LX, inline = "macdh_lx1")
string lib_macdh_LX_source = input.string("Flip Bearish", "", options = ["None","Flip Bullish","Flip Bearish","Shift Up","Shift Down"], group = GRP_LIB_MACDH_LX, inline = "macdh_lx1")
string lib_macdh_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDH_LX, inline = "macdh_lx2")
bool   lib_macdh_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_MACDH_LX, inline = "macdh_lx2")

string GRP_LIB_MACDH_SX   = "6-6.5 MACD Histogram – Short Exit"
bool   lib_macdh_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_MACDH_SX, inline = "macdh_sx1")
string lib_macdh_SX_source = input.string("Flip Bullish", "", options = ["None","Flip Bullish","Flip Bearish","Shift Up","Shift Down"], group = GRP_LIB_MACDH_SX, inline = "macdh_sx1")
string lib_macdh_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDH_SX, inline = "macdh_sx2")
bool   lib_macdh_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_MACDH_SX, inline = "macdh_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: MACD_HISTOGRAM ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ SIDE LIBRARY BLOCK: MACD_SIMPLE ██████
// GENERATOR_ID: MACD_SIMPLE
// SECURITY_CALLS: 6
// DEPENDENCIES: yamigushi/KevBot_TF_MACD_Simple/1
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// --- MACD_SIMPLE: INPUTS ---
string GRP_LIB_MACDS      = "6-7. Simple MACD"
bool   lib_macds_enabled  = input.bool(false, "Enable", group = GRP_LIB_MACDS, tooltip = "Enable Simple MACD Line interpreter (no zero context).")
int    lib_macds_slot     = input.int(0, "Side Table Slot", minval = 0, maxval = 10, group = GRP_LIB_MACDS, tooltip = "0 = Hidden, 1-10 = Table row position.")
string lib_macds_name     = input.string("MACD Simple", "Display Name", group = GRP_LIB_MACDS, tooltip = "Custom name shown in side table.")

// Simple MACD Parameters
string GRP_LIB_MACDS_PARAMS = "6-7.1 Simple MACD – Parameters"
int    lib_macds_fast     = input.int(12, "Fast Length", minval = 1, group = GRP_LIB_MACDS_PARAMS)
int    lib_macds_slow     = input.int(26, "Slow Length", minval = 1, group = GRP_LIB_MACDS_PARAMS)
int    lib_macds_signal   = input.int(9, "Signal Length", minval = 1, group = GRP_LIB_MACDS_PARAMS)

// Simple MACD Entry/Exit Configuration
string GRP_LIB_MACDS_LE   = "6-7.2 Simple MACD – Long Entry"
bool   lib_macds_LE_enable = input.bool(true, "Long Entry Trigger", group = GRP_LIB_MACDS_LE, inline = "macds_le1")
string lib_macds_LE_source = input.string("Bullish Cross", "", options = ["None","Bullish Cross","Bearish Cross"], group = GRP_LIB_MACDS_LE, inline = "macds_le1")
string lib_macds_LE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDS_LE, inline = "macds_le2")
bool   lib_macds_LE_bull   = input.bool(true, "Bullish Label", group = GRP_LIB_MACDS_LE, inline = "macds_le2")

string GRP_LIB_MACDS_LE_TF = "6-7.2.1 Long Entry – Confluences by TF"
bool   lib_macds_LEC_enable = input.bool(true, "Long Entry Confluence", group = GRP_LIB_MACDS_LE_TF, inline = "macds_lec1")
string lib_macds_LEC_func   = input.string("M>S↑", "", options = ["None","M>S↑","M>S↓","M<S↓","M<S↑"], group = GRP_LIB_MACDS_LE_TF, inline = "macds_lec1", tooltip = "M>S↑ = MACD > Signal, gap widening")
bool   lib_macds_LEC_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_MACDS_LE_TF, inline = "macds_lec1")
int    lib_macds_LE_tf1     = input.int(50, "TF 1 Score", inline = "macds_le_tf1", group = GRP_LIB_MACDS_LE_TF)
bool   lib_macds_LE_tf1_req = input.bool(false, "Required", inline = "macds_le_tf1", group = GRP_LIB_MACDS_LE_TF)
int    lib_macds_LE_tf2     = input.int(50, "TF 2 Score", inline = "macds_le_tf2", group = GRP_LIB_MACDS_LE_TF)
bool   lib_macds_LE_tf2_req = input.bool(false, "Required", inline = "macds_le_tf2", group = GRP_LIB_MACDS_LE_TF)
int    lib_macds_LE_tf3     = input.int(50, "TF 3 Score", inline = "macds_le_tf3", group = GRP_LIB_MACDS_LE_TF)
bool   lib_macds_LE_tf3_req = input.bool(false, "Required", inline = "macds_le_tf3", group = GRP_LIB_MACDS_LE_TF)
int    lib_macds_LE_tf4     = input.int(0, "TF 4 Score", inline = "macds_le_tf4", group = GRP_LIB_MACDS_LE_TF)
bool   lib_macds_LE_tf4_req = input.bool(false, "Required", inline = "macds_le_tf4", group = GRP_LIB_MACDS_LE_TF)
int    lib_macds_LE_tf5     = input.int(0, "TF 5 Score", inline = "macds_le_tf5", group = GRP_LIB_MACDS_LE_TF)
bool   lib_macds_LE_tf5_req = input.bool(false, "Required", inline = "macds_le_tf5", group = GRP_LIB_MACDS_LE_TF)
int    lib_macds_LE_tf6     = input.int(0, "TF 6 Score", inline = "macds_le_tf6", group = GRP_LIB_MACDS_LE_TF)
bool   lib_macds_LE_tf6_req = input.bool(false, "Required", inline = "macds_le_tf6", group = GRP_LIB_MACDS_LE_TF)

string GRP_LIB_MACDS_SE   = "6-7.3 Simple MACD – Short Entry"
bool   lib_macds_SE_enable = input.bool(true, "Short Entry Trigger", group = GRP_LIB_MACDS_SE, inline = "macds_se1")
string lib_macds_SE_source = input.string("Bearish Cross", "", options = ["None","Bullish Cross","Bearish Cross"], group = GRP_LIB_MACDS_SE, inline = "macds_se1")
string lib_macds_SE_sigType = input.string("Both", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDS_SE, inline = "macds_se2")
bool   lib_macds_SE_bear   = input.bool(true, "Bearish Label", group = GRP_LIB_MACDS_SE, inline = "macds_se2")

string GRP_LIB_MACDS_SE_TF = "6-7.3.1 Short Entry – Confluences by TF"
bool   lib_macds_SEC_enable = input.bool(true, "Short Entry Confluence", group = GRP_LIB_MACDS_SE_TF, inline = "macds_sec1")
string lib_macds_SEC_func   = input.string("M<S↓", "", options = ["None","M>S↑","M>S↓","M<S↓","M<S↑"], group = GRP_LIB_MACDS_SE_TF, inline = "macds_sec1", tooltip = "M<S↓ = MACD < Signal, gap widening")
bool   lib_macds_SEC_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_MACDS_SE_TF, inline = "macds_sec1")
int    lib_macds_SE_tf1     = input.int(50, "TF 1 Score", inline = "macds_se_tf1", group = GRP_LIB_MACDS_SE_TF)
bool   lib_macds_SE_tf1_req = input.bool(false, "Required", inline = "macds_se_tf1", group = GRP_LIB_MACDS_SE_TF)
int    lib_macds_SE_tf2     = input.int(50, "TF 2 Score", inline = "macds_se_tf2", group = GRP_LIB_MACDS_SE_TF)
bool   lib_macds_SE_tf2_req = input.bool(false, "Required", inline = "macds_se_tf2", group = GRP_LIB_MACDS_SE_TF)
int    lib_macds_SE_tf3     = input.int(50, "TF 3 Score", inline = "macds_se_tf3", group = GRP_LIB_MACDS_SE_TF)
bool   lib_macds_SE_tf3_req = input.bool(false, "Required", inline = "macds_se_tf3", group = GRP_LIB_MACDS_SE_TF)
int    lib_macds_SE_tf4     = input.int(0, "TF 4 Score", inline = "macds_se_tf4", group = GRP_LIB_MACDS_SE_TF)
bool   lib_macds_SE_tf4_req = input.bool(false, "Required", inline = "macds_se_tf4", group = GRP_LIB_MACDS_SE_TF)
int    lib_macds_SE_tf5     = input.int(0, "TF 5 Score", inline = "macds_se_tf5", group = GRP_LIB_MACDS_SE_TF)
bool   lib_macds_SE_tf5_req = input.bool(false, "Required", inline = "macds_se_tf5", group = GRP_LIB_MACDS_SE_TF)
int    lib_macds_SE_tf6     = input.int(0, "TF 6 Score", inline = "macds_se_tf6", group = GRP_LIB_MACDS_SE_TF)
bool   lib_macds_SE_tf6_req = input.bool(false, "Required", inline = "macds_se_tf6", group = GRP_LIB_MACDS_SE_TF)

string GRP_LIB_MACDS_LX   = "6-7.4 Simple MACD – Long Exit"
bool   lib_macds_LX_enable = input.bool(false, "Long Exit Trigger", group = GRP_LIB_MACDS_LX, inline = "macds_lx1")
string lib_macds_LX_source = input.string("Bearish Cross", "", options = ["None","Bullish Cross","Bearish Cross"], group = GRP_LIB_MACDS_LX, inline = "macds_lx1")
string lib_macds_LX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDS_LX, inline = "macds_lx2")
bool   lib_macds_LX_bear   = input.bool(false, "Bearish Label", group = GRP_LIB_MACDS_LX, inline = "macds_lx2")

string GRP_LIB_MACDS_SX   = "6-7.5 Simple MACD – Short Exit"
bool   lib_macds_SX_enable = input.bool(false, "Short Exit Trigger", group = GRP_LIB_MACDS_SX, inline = "macds_sx1")
string lib_macds_SX_source = input.string("Bullish Cross", "", options = ["None","Bullish Cross","Bearish Cross"], group = GRP_LIB_MACDS_SX, inline = "macds_sx1")
string lib_macds_SX_sigType = input.string("None", "Signal Type", options = ["None","Raw Only","Position Only","Both"], group = GRP_LIB_MACDS_SX, inline = "macds_sx2")
bool   lib_macds_SX_bull   = input.bool(false, "Bullish Label", group = GRP_LIB_MACDS_SX, inline = "macds_sx2")

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ END BLOCK: MACD_SIMPLE ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// LIB 1: Placeholder Timeframe Library (Side Module style)
// -----------------------------------------------
// //@version=6
// library("KevBot Placeholder TF Library", "kb_tf_demo")
// type TFModuleOutput => record(
//     longEntry, longExit, shortEntry, shortExit,
//     longConfluenceTF1, longConfluenceTF2, longConfluenceTF3,
//     longConfluenceTF4, longConfluenceTF5, longConfluenceTF6,
//     shortConfluenceTF1, shortConfluenceTF2, shortConfluenceTF3,
//     shortConfluenceTF4, shortConfluenceTF5, shortConfluenceTF6)
// TFModuleOutput getTFDemo(float paramA, float paramB) => TFModuleOutput(
//     true, false, false, false,
//     true, true, false, false, false, false,
//     false, false, false, false, false, false)
// LIB 2: Placeholder Top Library (Top Module style)
// -----------------------------------------------
// //@version=6
// library("KevBot Placeholder Top Library", "kb_top_demo")
// type TopModuleOutput => record(outA, outB, outC, outD)
// TopModuleOutput getTopDemo(float a, float b, float c) => TopModuleOutput(a + b, b + c, a - c, a + b + c)
// true, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false)
//
// LIB 2: Placeholder Top Library (Top Module style)
// -----------------------------------------------
// //@version=6
// library("KevBot Placeholder Top Library", "kb_top_demo", true)
//
// type TopModuleOutput =>
//     float outA
//     float outB
//     float outC
//     float outD
//
// TopModuleOutput getTopDemo(float paramA, float paramB, float paramC) =>
//     // Placeholder implementation
//     TopModuleOutput(paramA + paramB, paramB + paramC, paramA - paramC, paramA + paramB + paramC)
//
// In the main Toolkit script, you will eventually:
// // import kb_tf_demo as tfLib
// // import kb_top_demo as topLib
// and then call their APIs inside the Confluence / Entry / Exit engines.

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//* 7. MODULE LOADER SYSTEM */
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Import KevBot libraries (Top + TF Placeholder)
// IMPORTANT: These imports must match your actual published library names.
import yamigushi/KevBot_Top_Minimal/1               as top1Lib
import yamigushi/KevBot_TF_Placeholder/5            as side1Lib
import yamigushi/KevBot_TF_EMA_Stack/7              as tfEMAStack  // v6 uses buildOutput() hybrid approach
import yamigushi/KevBot_TF_MACD_Simple/1            as tfMACDSimple    // Simple MACD Line (no zero context)
import yamigushi/KevBot_TF_MACD_Line/1              as tfMACDLine      // MACD Line with zero context
import yamigushi/KevBot_TF_MACD_Histogram/1         as tfMACDHistogram // MACD Histogram momentum
import yamigushi/KevBot_TF_MACD_Divergence/1        as tfMACDDivergence // MACD Divergence detection
import yamigushi/KevBot_TF_UTBot/1                  as tfUTBot          // UT Bot ATR trailing stop
import yamigushi/KevBot_TF_VWAP/1                   as tfVWAP           // VWAP with SD bands
import yamigushi/KevBot_TF_RVOL/1                   as tfRVOL           // Relative volume
import yamigushi/KevBot_TF_Swing123/1              as tfSwing123       // 1-2-3 reversal patterns


// NOTE: Legacy _side1_moduleActive and _side2_moduleActive moved to v2 placeholder section

//──────────────────────────────────────────────────────────────────────────────
// UT BOT HELPER FUNCTION (must be at global scope)
//──────────────────────────────────────────────────────────────────────────────
// Calculates ATR trailing stop with ratcheting behavior.
// Uses self-referential series (NOT var) so it can be evaluated per-TF via request.security()
// Returns: [trailingStop, source]
_kb_calcUTBot(float _keyVal, int _atrPer) =>
    float _src = close
    float _atr = ta.atr(_atrPer)
    float _nLoss = _keyVal * _atr
    // Self-referential trailing stop calculation (no var keyword)
    float _stop = 0.0
    if bar_index == 0
        _stop := _src - _nLoss
    else if _src > nz(_stop[1], 0) and _src[1] > nz(_stop[1], 0)
        _stop := math.max(nz(_stop[1]), _src - _nLoss)
    else if _src < nz(_stop[1], 0) and _src[1] < nz(_stop[1], 0)
        _stop := math.min(nz(_stop[1]), _src + _nLoss)
    else if _src > nz(_stop[1], 0)
        _stop := _src - _nLoss
    else
        _stop := _src + _nLoss
    [_stop, _src]

// UT Bot with Heikin Ashi source option
_kb_calcUTBotHA(float _keyVal, int _atrPer, float _haSrc) =>
    float _src = _haSrc
    float _atr = ta.atr(_atrPer)
    float _nLoss = _keyVal * _atr
    float _stop = 0.0
    if bar_index == 0
        _stop := _src - _nLoss
    else if _src > nz(_stop[1], 0) and _src[1] > nz(_stop[1], 0)
        _stop := math.max(nz(_stop[1]), _src - _nLoss)
    else if _src < nz(_stop[1], 0) and _src[1] < nz(_stop[1], 0)
        _stop := math.min(nz(_stop[1]), _src + _nLoss)
    else if _src > nz(_stop[1], 0)
        _stop := _src - _nLoss
    else
        _stop := _src + _nLoss
    [_stop, _src]

//──────────────────────────────────────────────────────────────────────────────
// MACD DIVERGENCE HELPER FUNCTION (must be at global scope)
//──────────────────────────────────────────────────────────────────────────────
// This helper finds swing points and tracks MACD values at those swings.
// Used by MACD Divergence implementation in Side Module loaders.
// Returns: [priceLow1, priceLow2, macdLow1, macdLow2, priceHigh1, priceHigh2, macdHigh1, macdHigh2, newSwingLow, newSwingHigh]
_kb_getSwingData(float _macd, int _pivotLen, int _maxLookback) =>
    float _pl = ta.pivotlow(low, _pivotLen, _pivotLen)
    float _ph = ta.pivothigh(high, _pivotLen, _pivotLen)

    // Track last two swing lows
    var float _swingLow1 = na
    var float _swingLow2 = na
    var float _macdAtLow1 = na
    var float _macdAtLow2 = na
    var int _lowBar1 = na

    if not na(_pl)
        _swingLow2 := _swingLow1
        _macdAtLow2 := _macdAtLow1
        _swingLow1 := _pl
        _macdAtLow1 := _macd[_pivotLen]
        _lowBar1 := bar_index

    // Track last two swing highs
    var float _swingHigh1 = na
    var float _swingHigh2 = na
    var float _macdAtHigh1 = na
    var float _macdAtHigh2 = na
    var int _highBar1 = na

    if not na(_ph)
        _swingHigh2 := _swingHigh1
        _macdAtHigh2 := _macdAtHigh1
        _swingHigh1 := _ph
        _macdAtHigh1 := _macd[_pivotLen]
        _highBar1 := bar_index

    // Check if swings are within lookback
    bool _lowValid = not na(_lowBar1) and (bar_index - _lowBar1) < _maxLookback
    bool _highValid = not na(_highBar1) and (bar_index - _highBar1) < _maxLookback

    float _pL1 = _lowValid ? _swingLow1 : na
    float _pL2 = _lowValid ? _swingLow2 : na
    float _mL1 = _lowValid ? _macdAtLow1 : na
    float _mL2 = _lowValid ? _macdAtLow2 : na
    float _pH1 = _highValid ? _swingHigh1 : na
    float _pH2 = _highValid ? _swingHigh2 : na
    float _mH1 = _highValid ? _macdAtHigh1 : na
    float _mH2 = _highValid ? _macdAtHigh2 : na
    bool _newLow = not na(_pl)
    bool _newHigh = not na(_ph)

    [_pL1, _pL2, _mL1, _mL2, _pH1, _pH2, _mH1, _mH2, _newLow, _newHigh]

//──────────────────────────────────────────────────────────────────────────────
// VWAP HELPER FUNCTION (must be at global scope)
//──────────────────────────────────────────────────────────────────────────────
// Calculates session-anchored VWAP with cumulative standard deviation.
// Uses self-referential series (NOT var) so it can be evaluated per-TF via request.security()
// Returns: [vwap, sd]
_kb_calcVWAP() =>
    // Session reset detection (new day)
    bool _newSession = ta.change(time("D")) != 0

    // Self-referential cumulative sums (no var keyword for request.security compatibility)
    float _sumPV = 0.0    // sum(price × volume)
    float _sumV = 0.0     // sum(volume)
    float _sumPV2 = 0.0   // sum(price² × volume)

    if bar_index == 0 or _newSession
        _sumPV := close * volume
        _sumV := volume
        _sumPV2 := close * close * volume
    else
        _sumPV := nz(_sumPV[1]) + close * volume
        _sumV := nz(_sumV[1]) + volume
        _sumPV2 := nz(_sumPV2[1]) + close * close * volume

    // Calculate VWAP
    float _vwap = _sumV > 0 ? _sumPV / _sumV : close

    // Calculate standard deviation using variance formula: Var(X) = E[X²] - E[X]²
    // Volume-weighted variance = (sumPV2 / sumV) - (vwap²)
    float _variance = _sumV > 0 ? (_sumPV2 / _sumV) - (_vwap * _vwap) : 0.0
    float _sd = math.sqrt(math.max(_variance, 0))

    [_vwap, _sd]

//──────────────────────────────────────────────────────────────────────────────
// WEEKLY ANCHORED VWAP (resets at start of week)
//──────────────────────────────────────────────────────────────────────────────
_kb_calcVWAP_W() =>
    bool _newSession = ta.change(time("W")) != 0
    float _sumPV = 0.0
    float _sumV = 0.0
    float _sumPV2 = 0.0
    if bar_index == 0 or _newSession
        _sumPV := close * volume
        _sumV := volume
        _sumPV2 := close * close * volume
    else
        _sumPV := nz(_sumPV[1]) + close * volume
        _sumV := nz(_sumV[1]) + volume
        _sumPV2 := nz(_sumPV2[1]) + close * close * volume
    float _vwap = _sumV > 0 ? _sumPV / _sumV : close
    float _variance = _sumV > 0 ? (_sumPV2 / _sumV) - (_vwap * _vwap) : 0.0
    float _sd = math.sqrt(math.max(_variance, 0))
    [_vwap, _sd]

//──────────────────────────────────────────────────────────────────────────────
// MONTHLY ANCHORED VWAP (resets at start of month)
//──────────────────────────────────────────────────────────────────────────────
_kb_calcVWAP_M() =>
    bool _newSession = ta.change(time("M")) != 0
    float _sumPV = 0.0
    float _sumV = 0.0
    float _sumPV2 = 0.0
    if bar_index == 0 or _newSession
        _sumPV := close * volume
        _sumV := volume
        _sumPV2 := close * close * volume
    else
        _sumPV := nz(_sumPV[1]) + close * volume
        _sumV := nz(_sumV[1]) + volume
        _sumPV2 := nz(_sumPV2[1]) + close * close * volume
    float _vwap = _sumV > 0 ? _sumPV / _sumV : close
    float _variance = _sumV > 0 ? (_sumPV2 / _sumV) - (_vwap * _vwap) : 0.0
    float _sd = math.sqrt(math.max(_variance, 0))
    [_vwap, _sd]

//──────────────────────────────────────────────────────────────────────────────
// VWAP ZONE LABEL HELPER
//──────────────────────────────────────────────────────────────────────────────
// Returns zone label based on price position relative to VWAP bands
_kb_vwapZoneLabel(float price, float vwap, float sd, float sd1Mult, float sd2Mult) =>
    string lab = "na"
    if not na(price) and not na(vwap) and not na(sd) and sd > 0
        float upperBand2 = vwap + (sd2Mult * sd)
        float upperBand1 = vwap + (sd1Mult * sd)
        float atVwapUpper = vwap + (0.5 * sd)
        float atVwapLower = vwap - (0.5 * sd)
        float lowerBand1 = vwap - (sd1Mult * sd)
        float lowerBand2 = vwap - (sd2Mult * sd)

        if price > upperBand2
            lab := ">+2σ"
        else if price > upperBand1
            lab := ">+1σ"
        else if price > atVwapUpper
            lab := ">V"
        else if price >= atVwapLower
            lab := "@V"
        else if price >= lowerBand1
            lab := "<V"
        else if price >= lowerBand2
            lab := "<-1σ"
        else
            lab := "<-2σ"
    lab

//──────────────────────────────────────────────────────────────────────────────
// VWAP ZONE CONDITION MATCHER
//──────────────────────────────────────────────────────────────────────────────
// Checks if a zone label matches the user's configured condition grouping
_kb_vwapZoneMatch(string zone, string condition) =>
    bool match = false
    if condition == "None"
        match := false
    else if condition == "Above VWAP"
        match := zone == ">V" or zone == ">+1σ" or zone == ">+2σ"
    else if condition == "At/Above VWAP"
        match := zone == "@V" or zone == ">V" or zone == ">+1σ" or zone == ">+2σ"
    else if condition == "At VWAP"
        match := zone == "@V"
    else if condition == "At/Below VWAP"
        match := zone == "@V" or zone == "<V" or zone == "<-1σ" or zone == "<-2σ"
    else if condition == "Below VWAP"
        match := zone == "<V" or zone == "<-1σ" or zone == "<-2σ"
    else if condition == "Extended Above"
        match := zone == ">+1σ" or zone == ">+2σ"
    else if condition == "Extended Below"
        match := zone == "<-1σ" or zone == "<-2σ"
    else if condition == "Extreme High"
        match := zone == ">+2σ"
    else if condition == "Extreme Low"
        match := zone == "<-2σ"
    match

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 8.0 PHASE 2B — INTERNAL NORMALIZED OUTPUT (PARALLEL OUTPUTS)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// Phase 2B introduces a Toolkit-internal, normalized output shape that supports:
//   • 10 Trigger slots (A–J) on chart timeframe
//   • 10 Condition slots (A–J) per TF (tf1–tf6)
//   • TF labels (tf1_label..tf6_label)
//
// NOTE:
//   • This does NOT change legacy behavior yet.
//   • Downstream blocks (8/9/12/13) may still consume legacy fields until
//     their Phase 2B updates land.
//   • Legacy libraries are mapped into slot A only (others false).
//
// This is Option A: Parallel Outputs.
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Toolkit-internal normalized output (NOT exported)
// Conditions are per TF so that any selected Condition slot can be evaluated
// against each timeframe independently.

type KB_TF_Out_V2
    // TF state labels
    string tf1_label
    string tf2_label
    string tf3_label
    string tf4_label
    string tf5_label
    string tf6_label

    // Condition slots per TF (A–J × tf1–tf6)
    bool condA_tf1
    bool condA_tf2
    bool condA_tf3
    bool condA_tf4
    bool condA_tf5
    bool condA_tf6

    bool condB_tf1
    bool condB_tf2
    bool condB_tf3
    bool condB_tf4
    bool condB_tf5
    bool condB_tf6

    bool condC_tf1
    bool condC_tf2
    bool condC_tf3
    bool condC_tf4
    bool condC_tf5
    bool condC_tf6

    bool condD_tf1
    bool condD_tf2
    bool condD_tf3
    bool condD_tf4
    bool condD_tf5
    bool condD_tf6

    bool condE_tf1
    bool condE_tf2
    bool condE_tf3
    bool condE_tf4
    bool condE_tf5
    bool condE_tf6

    bool condF_tf1
    bool condF_tf2
    bool condF_tf3
    bool condF_tf4
    bool condF_tf5
    bool condF_tf6

    bool condG_tf1
    bool condG_tf2
    bool condG_tf3
    bool condG_tf4
    bool condG_tf5
    bool condG_tf6

    bool condH_tf1
    bool condH_tf2
    bool condH_tf3
    bool condH_tf4
    bool condH_tf5
    bool condH_tf6

    bool condI_tf1
    bool condI_tf2
    bool condI_tf3
    bool condI_tf4
    bool condI_tf5
    bool condI_tf6

    bool condJ_tf1
    bool condJ_tf2
    bool condJ_tf3
    bool condJ_tf4
    bool condJ_tf5
    bool condJ_tf6

    // Trigger slots (chart timeframe events)
    bool trigA
    bool trigB
    bool trigC
    bool trigD
    bool trigE
    bool trigF
    bool trigG
    bool trigH
    bool trigI
    bool trigJ

    // Trigger metadata (optional, legacy-compatible)
    float trigger_price
    string trigger_label


// Phase 2B helper: map TFModuleOutput (from side1Lib) → KB_TF_Out_V2
// Libraries now output all 10 conditions (A-J) per TF and 10 triggers (A-J).
_kb_mapLibToV2(side1Lib.TFModuleOutput o) =>
    KB_TF_Out_V2.new(
        // labels
        o.tf1_label, o.tf2_label, o.tf3_label, o.tf4_label, o.tf5_label, o.tf6_label,

        // condA
        o.condA_tf1, o.condA_tf2, o.condA_tf3, o.condA_tf4, o.condA_tf5, o.condA_tf6,
        // condB
        o.condB_tf1, o.condB_tf2, o.condB_tf3, o.condB_tf4, o.condB_tf5, o.condB_tf6,
        // condC
        o.condC_tf1, o.condC_tf2, o.condC_tf3, o.condC_tf4, o.condC_tf5, o.condC_tf6,
        // condD
        o.condD_tf1, o.condD_tf2, o.condD_tf3, o.condD_tf4, o.condD_tf5, o.condD_tf6,
        // condE
        o.condE_tf1, o.condE_tf2, o.condE_tf3, o.condE_tf4, o.condE_tf5, o.condE_tf6,
        // condF
        o.condF_tf1, o.condF_tf2, o.condF_tf3, o.condF_tf4, o.condF_tf5, o.condF_tf6,
        // condG
        o.condG_tf1, o.condG_tf2, o.condG_tf3, o.condG_tf4, o.condG_tf5, o.condG_tf6,
        // condH
        o.condH_tf1, o.condH_tf2, o.condH_tf3, o.condH_tf4, o.condH_tf5, o.condH_tf6,
        // condI
        o.condI_tf1, o.condI_tf2, o.condI_tf3, o.condI_tf4, o.condI_tf5, o.condI_tf6,
        // condJ
        o.condJ_tf1, o.condJ_tf2, o.condJ_tf3, o.condJ_tf4, o.condJ_tf5, o.condJ_tf6,

        // triggers A-J
        o.trigA, o.trigB, o.trigC, o.trigD, o.trigE,
        o.trigF, o.trigG, o.trigH, o.trigI, o.trigJ,

        // trigger metadata
        o.trigger_price,
        o.trigger_label
    )


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 7.1 TOP MODULE LOADER (TOP MODULE 1 PROTOTYPE)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// Expected Top library API:
//   type TopModuleOutput
//   export getTopModule(float pA, float pB, float pC, float pD, float pE, float pF)
//
// The Toolkit does not yet define real Top modules; this is placeholder wiring.
// The output record fields (outA..outD) are placeholders only.
//

// Raw Top-Module-1 output record
var top1Lib.TopModuleOutput top1_raw = top1Lib.getTopModule(
    top1_paramA, top1_paramB, top1_paramC,
    top1_paramD, top1_paramE, top1_paramF)

// When disabled, force a neutral TopModuleOutput
if not (top1_enabled and top1_library != "None")
    top1_raw := top1Lib.getTopModule(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ██████ LIBRARY-CENTRIC LOADERS (V2 ARCHITECTURE) ██████
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// Each library has its own loader that only runs if enabled.
// Outputs are stored in lib_*_v2 variables for slot-based rendering.
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Helper to resolve timeframe string for request.security (shared)
_tf_res_v2(string tfRes) => tfRes == "Chart" or tfRes == "" ? timeframe.period : tfRes

//──────────────────────────────────────────────────────────────────────────────
// EMA STACK LOADER (V2)
// Only executes request.security() calls if lib_ema_enabled is true
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_ema_v2 = KB_TF_Out_V2.new()

if lib_ema_enabled
    // Fetch HTF EMAs for each of the 6 timeframes
    [_ema_eS1, _ema_eM1, _ema_eL1] = request.security(syminfo.tickerid, _tf_res_v2(tf1),
        [ta.ema(close, lib_ema_short), ta.ema(close, lib_ema_medium), ta.ema(close, lib_ema_long)],
        barmerge.gaps_off, barmerge.lookahead_off)

    [_ema_eS2, _ema_eM2, _ema_eL2] = request.security(syminfo.tickerid, _tf_res_v2(tf2),
        [ta.ema(close, lib_ema_short), ta.ema(close, lib_ema_medium), ta.ema(close, lib_ema_long)],
        barmerge.gaps_off, barmerge.lookahead_off)

    [_ema_eS3, _ema_eM3, _ema_eL3] = request.security(syminfo.tickerid, _tf_res_v2(tf3),
        [ta.ema(close, lib_ema_short), ta.ema(close, lib_ema_medium), ta.ema(close, lib_ema_long)],
        barmerge.gaps_off, barmerge.lookahead_off)

    [_ema_eS4, _ema_eM4, _ema_eL4] = request.security(syminfo.tickerid, _tf_res_v2(tf4),
        [ta.ema(close, lib_ema_short), ta.ema(close, lib_ema_medium), ta.ema(close, lib_ema_long)],
        barmerge.gaps_off, barmerge.lookahead_off)

    [_ema_eS5, _ema_eM5, _ema_eL5] = request.security(syminfo.tickerid, _tf_res_v2(tf5),
        [ta.ema(close, lib_ema_short), ta.ema(close, lib_ema_medium), ta.ema(close, lib_ema_long)],
        barmerge.gaps_off, barmerge.lookahead_off)

    [_ema_eS6, _ema_eM6, _ema_eL6] = request.security(syminfo.tickerid, _tf_res_v2(tf6),
        [ta.ema(close, lib_ema_short), ta.ema(close, lib_ema_medium), ta.ema(close, lib_ema_long)],
        barmerge.gaps_off, barmerge.lookahead_off)

    // Chart timeframe EMAs (for trigger detection)
    float _ema_eS_chart = ta.ema(close, lib_ema_short)
    float _ema_eM_chart = ta.ema(close, lib_ema_medium)
    float _ema_eL_chart = ta.ema(close, lib_ema_long)

    // Previous bar values (for crossover detection)
    float _ema_eS_prev = _ema_eS_chart[1]
    float _ema_eM_prev = _ema_eM_chart[1]

    // Call library's builder function
    tfEMAStack.TFModuleOutput _emaOut = tfEMAStack.buildOutput(
        _ema_eS1, _ema_eM1, _ema_eL1,
        _ema_eS2, _ema_eM2, _ema_eL2,
        _ema_eS3, _ema_eM3, _ema_eL3,
        _ema_eS4, _ema_eM4, _ema_eL4,
        _ema_eS5, _ema_eM5, _ema_eL5,
        _ema_eS6, _ema_eM6, _ema_eL6,
        _ema_eS_chart, _ema_eM_chart, _ema_eL_chart,
        _ema_eS_prev, _ema_eM_prev, _ema_eL_chart[1],
        close
    )

    // Map to normalized V2 output
    lib_ema_v2 := KB_TF_Out_V2.new(
        _emaOut.tf1_label, _emaOut.tf2_label, _emaOut.tf3_label,
        _emaOut.tf4_label, _emaOut.tf5_label, _emaOut.tf6_label,
        _emaOut.condA_tf1, _emaOut.condA_tf2, _emaOut.condA_tf3,
        _emaOut.condA_tf4, _emaOut.condA_tf5, _emaOut.condA_tf6,
        _emaOut.condB_tf1, _emaOut.condB_tf2, _emaOut.condB_tf3,
        _emaOut.condB_tf4, _emaOut.condB_tf5, _emaOut.condB_tf6,
        _emaOut.condC_tf1, _emaOut.condC_tf2, _emaOut.condC_tf3,
        _emaOut.condC_tf4, _emaOut.condC_tf5, _emaOut.condC_tf6,
        _emaOut.condD_tf1, _emaOut.condD_tf2, _emaOut.condD_tf3,
        _emaOut.condD_tf4, _emaOut.condD_tf5, _emaOut.condD_tf6,
        _emaOut.condE_tf1, _emaOut.condE_tf2, _emaOut.condE_tf3,
        _emaOut.condE_tf4, _emaOut.condE_tf5, _emaOut.condE_tf6,
        _emaOut.condF_tf1, _emaOut.condF_tf2, _emaOut.condF_tf3,
        _emaOut.condF_tf4, _emaOut.condF_tf5, _emaOut.condF_tf6,
        _emaOut.condG_tf1, _emaOut.condG_tf2, _emaOut.condG_tf3,
        _emaOut.condG_tf4, _emaOut.condG_tf5, _emaOut.condG_tf6,
        _emaOut.condH_tf1, _emaOut.condH_tf2, _emaOut.condH_tf3,
        _emaOut.condH_tf4, _emaOut.condH_tf5, _emaOut.condH_tf6,
        _emaOut.condI_tf1, _emaOut.condI_tf2, _emaOut.condI_tf3,
        _emaOut.condI_tf4, _emaOut.condI_tf5, _emaOut.condI_tf6,
        _emaOut.condJ_tf1, _emaOut.condJ_tf2, _emaOut.condJ_tf3,
        _emaOut.condJ_tf4, _emaOut.condJ_tf5, _emaOut.condJ_tf6,
        _emaOut.trigA, _emaOut.trigB, _emaOut.trigC, _emaOut.trigD, _emaOut.trigE,
        _emaOut.trigF, _emaOut.trigG, _emaOut.trigH, _emaOut.trigI, _emaOut.trigJ,
        _emaOut.trigger_price, _emaOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END EMA STACK LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//──────────────────────────────────────────────────────────────────────────────
// RVOL LOADER (V2)
// Only executes request.security() calls if lib_rvol_enabled is true
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_rvol_v2 = KB_TF_Out_V2.new()

if lib_rvol_enabled
    // Calculate RVOL for each timeframe
    // RVOL = current volume / average volume over lookback period
    float _rvol_1 = request.security(syminfo.tickerid, _tf_res_v2(tf1), volume / ta.sma(volume, lib_rvol_lookback), barmerge.gaps_off, barmerge.lookahead_off)
    float _rvol_2 = request.security(syminfo.tickerid, _tf_res_v2(tf2), volume / ta.sma(volume, lib_rvol_lookback), barmerge.gaps_off, barmerge.lookahead_off)
    float _rvol_3 = request.security(syminfo.tickerid, _tf_res_v2(tf3), volume / ta.sma(volume, lib_rvol_lookback), barmerge.gaps_off, barmerge.lookahead_off)
    float _rvol_4 = request.security(syminfo.tickerid, _tf_res_v2(tf4), volume / ta.sma(volume, lib_rvol_lookback), barmerge.gaps_off, barmerge.lookahead_off)
    float _rvol_5 = request.security(syminfo.tickerid, _tf_res_v2(tf5), volume / ta.sma(volume, lib_rvol_lookback), barmerge.gaps_off, barmerge.lookahead_off)
    float _rvol_6 = request.security(syminfo.tickerid, _tf_res_v2(tf6), volume / ta.sma(volume, lib_rvol_lookback), barmerge.gaps_off, barmerge.lookahead_off)

    // Chart timeframe RVOL (for triggers)
    float _rvol_chart = volume / ta.sma(volume, lib_rvol_lookback)
    float _rvol_prev = _rvol_chart[1]

    // Call library's builder function
    tfRVOL.TFModuleOutput _rvolOut = tfRVOL.buildOutput(
        _rvol_1, _rvol_2, _rvol_3, _rvol_4, _rvol_5, _rvol_6,
        lib_rvol_highTh, lib_rvol_veryHighTh, lib_rvol_extremeTh,
        _rvol_chart, _rvol_prev,
        close
    )

    // Map to normalized V2 output
    lib_rvol_v2 := KB_TF_Out_V2.new(
        _rvolOut.tf1_label, _rvolOut.tf2_label, _rvolOut.tf3_label,
        _rvolOut.tf4_label, _rvolOut.tf5_label, _rvolOut.tf6_label,
        _rvolOut.condA_tf1, _rvolOut.condA_tf2, _rvolOut.condA_tf3,
        _rvolOut.condA_tf4, _rvolOut.condA_tf5, _rvolOut.condA_tf6,
        _rvolOut.condB_tf1, _rvolOut.condB_tf2, _rvolOut.condB_tf3,
        _rvolOut.condB_tf4, _rvolOut.condB_tf5, _rvolOut.condB_tf6,
        _rvolOut.condC_tf1, _rvolOut.condC_tf2, _rvolOut.condC_tf3,
        _rvolOut.condC_tf4, _rvolOut.condC_tf5, _rvolOut.condC_tf6,
        _rvolOut.condD_tf1, _rvolOut.condD_tf2, _rvolOut.condD_tf3,
        _rvolOut.condD_tf4, _rvolOut.condD_tf5, _rvolOut.condD_tf6,
        _rvolOut.condE_tf1, _rvolOut.condE_tf2, _rvolOut.condE_tf3,
        _rvolOut.condE_tf4, _rvolOut.condE_tf5, _rvolOut.condE_tf6,
        _rvolOut.condF_tf1, _rvolOut.condF_tf2, _rvolOut.condF_tf3,
        _rvolOut.condF_tf4, _rvolOut.condF_tf5, _rvolOut.condF_tf6,
        _rvolOut.condG_tf1, _rvolOut.condG_tf2, _rvolOut.condG_tf3,
        _rvolOut.condG_tf4, _rvolOut.condG_tf5, _rvolOut.condG_tf6,
        _rvolOut.condH_tf1, _rvolOut.condH_tf2, _rvolOut.condH_tf3,
        _rvolOut.condH_tf4, _rvolOut.condH_tf5, _rvolOut.condH_tf6,
        _rvolOut.condI_tf1, _rvolOut.condI_tf2, _rvolOut.condI_tf3,
        _rvolOut.condI_tf4, _rvolOut.condI_tf5, _rvolOut.condI_tf6,
        _rvolOut.condJ_tf1, _rvolOut.condJ_tf2, _rvolOut.condJ_tf3,
        _rvolOut.condJ_tf4, _rvolOut.condJ_tf5, _rvolOut.condJ_tf6,
        _rvolOut.trigA, _rvolOut.trigB, _rvolOut.trigC, _rvolOut.trigD, _rvolOut.trigE,
        _rvolOut.trigF, _rvolOut.trigG, _rvolOut.trigH, _rvolOut.trigI, _rvolOut.trigJ,
        _rvolOut.trigger_price, _rvolOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END RVOL LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//──────────────────────────────────────────────────────────────────────────────
// UT BOT LOADER (V2)
// Only executes request.security() calls if lib_utbot_enabled is true
// NOTE: UT Bot requires var state for trailing stop, so logic is in toolkit
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_utbot_v2 = KB_TF_Out_V2.new()

// UT Bot trailing stop calculation function (called per-TF)
// Returns [trailingStop, direction]
_utbot_stop(float src, float atr, float keyVal, float prevStop, int prevDir) =>
    float nLoss = keyVal * atr
    int dir = prevDir
    float stop = prevStop
    if src > nz(prevStop, src)
        stop := math.max(nz(prevStop, src - nLoss), src - nLoss)
        dir := 1
    else
        stop := math.min(nz(prevStop, src + nLoss), src + nLoss)
        dir := -1
    [stop, dir]

// Var state for trailing stops (each TF needs persistent state)
var float _utbot_stop1 = na
var float _utbot_stop2 = na
var float _utbot_stop3 = na
var float _utbot_stop4 = na
var float _utbot_stop5 = na
var float _utbot_stop6 = na
var int   _utbot_dir1 = 0
var int   _utbot_dir2 = 0
var int   _utbot_dir3 = 0
var int   _utbot_dir4 = 0
var int   _utbot_dir5 = 0
var int   _utbot_dir6 = 0

if lib_utbot_enabled
    // Get source (Heikin Ashi or regular close)
    float _utbot_src = lib_utbot_useHA ? (open + high + low + close) / 4 : close

    // Fetch close and ATR for each TF
    [_utbot_c1, _utbot_a1] = request.security(syminfo.tickerid, _tf_res_v2(tf1),
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)
    [_utbot_c2, _utbot_a2] = request.security(syminfo.tickerid, _tf_res_v2(tf2),
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)
    [_utbot_c3, _utbot_a3] = request.security(syminfo.tickerid, _tf_res_v2(tf3),
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)
    [_utbot_c4, _utbot_a4] = request.security(syminfo.tickerid, _tf_res_v2(tf4),
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)
    [_utbot_c5, _utbot_a5] = request.security(syminfo.tickerid, _tf_res_v2(tf5),
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)
    [_utbot_c6, _utbot_a6] = request.security(syminfo.tickerid, _tf_res_v2(tf6),
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)
    // Additional security call for chart TF trigger detection
    [_utbot_c_chart, _utbot_a_chart] = request.security(syminfo.tickerid, timeframe.period,
        [_utbot_src, ta.atr(lib_utbot_atrlen)], barmerge.gaps_off, barmerge.lookahead_off)

    // Calculate trailing stops for each TF
    [s1, d1] = _utbot_stop(_utbot_c1, _utbot_a1, lib_utbot_keyval, _utbot_stop1, _utbot_dir1)
    _utbot_stop1 := s1
    _utbot_dir1  := d1

    [s2, d2] = _utbot_stop(_utbot_c2, _utbot_a2, lib_utbot_keyval, _utbot_stop2, _utbot_dir2)
    _utbot_stop2 := s2
    _utbot_dir2  := d2

    [s3, d3] = _utbot_stop(_utbot_c3, _utbot_a3, lib_utbot_keyval, _utbot_stop3, _utbot_dir3)
    _utbot_stop3 := s3
    _utbot_dir3  := d3

    [s4, d4] = _utbot_stop(_utbot_c4, _utbot_a4, lib_utbot_keyval, _utbot_stop4, _utbot_dir4)
    _utbot_stop4 := s4
    _utbot_dir4  := d4

    [s5, d5] = _utbot_stop(_utbot_c5, _utbot_a5, lib_utbot_keyval, _utbot_stop5, _utbot_dir5)
    _utbot_stop5 := s5
    _utbot_dir5  := d5

    [s6, d6] = _utbot_stop(_utbot_c6, _utbot_a6, lib_utbot_keyval, _utbot_stop6, _utbot_dir6)
    _utbot_stop6 := s6
    _utbot_dir6  := d6

    // Chart TF values for triggers
    float _utbot_p_chart = _utbot_c_chart
    float _utbot_s_chart = _utbot_stop1  // Use TF1 stop for chart (simplified)
    float _utbot_p_prev = _utbot_c_chart[1]
    float _utbot_s_prev = _utbot_stop1[1]

    // Call library's builder function
    tfUTBot.TFModuleOutput _utbotOut = tfUTBot.buildOutput(
        _utbot_c1, _utbot_stop1,
        _utbot_c2, _utbot_stop2,
        _utbot_c3, _utbot_stop3,
        _utbot_c4, _utbot_stop4,
        _utbot_c5, _utbot_stop5,
        _utbot_c6, _utbot_stop6,
        _utbot_p_chart, _utbot_s_chart, _utbot_p_prev, _utbot_s_prev,
        close
    )

    // Map to normalized V2 output
    lib_utbot_v2 := KB_TF_Out_V2.new(
        _utbotOut.tf1_label, _utbotOut.tf2_label, _utbotOut.tf3_label,
        _utbotOut.tf4_label, _utbotOut.tf5_label, _utbotOut.tf6_label,
        _utbotOut.condA_tf1, _utbotOut.condA_tf2, _utbotOut.condA_tf3,
        _utbotOut.condA_tf4, _utbotOut.condA_tf5, _utbotOut.condA_tf6,
        _utbotOut.condB_tf1, _utbotOut.condB_tf2, _utbotOut.condB_tf3,
        _utbotOut.condB_tf4, _utbotOut.condB_tf5, _utbotOut.condB_tf6,
        _utbotOut.condC_tf1, _utbotOut.condC_tf2, _utbotOut.condC_tf3,
        _utbotOut.condC_tf4, _utbotOut.condC_tf5, _utbotOut.condC_tf6,
        _utbotOut.condD_tf1, _utbotOut.condD_tf2, _utbotOut.condD_tf3,
        _utbotOut.condD_tf4, _utbotOut.condD_tf5, _utbotOut.condD_tf6,
        _utbotOut.condE_tf1, _utbotOut.condE_tf2, _utbotOut.condE_tf3,
        _utbotOut.condE_tf4, _utbotOut.condE_tf5, _utbotOut.condE_tf6,
        _utbotOut.condF_tf1, _utbotOut.condF_tf2, _utbotOut.condF_tf3,
        _utbotOut.condF_tf4, _utbotOut.condF_tf5, _utbotOut.condF_tf6,
        _utbotOut.condG_tf1, _utbotOut.condG_tf2, _utbotOut.condG_tf3,
        _utbotOut.condG_tf4, _utbotOut.condG_tf5, _utbotOut.condG_tf6,
        _utbotOut.condH_tf1, _utbotOut.condH_tf2, _utbotOut.condH_tf3,
        _utbotOut.condH_tf4, _utbotOut.condH_tf5, _utbotOut.condH_tf6,
        _utbotOut.condI_tf1, _utbotOut.condI_tf2, _utbotOut.condI_tf3,
        _utbotOut.condI_tf4, _utbotOut.condI_tf5, _utbotOut.condI_tf6,
        _utbotOut.condJ_tf1, _utbotOut.condJ_tf2, _utbotOut.condJ_tf3,
        _utbotOut.condJ_tf4, _utbotOut.condJ_tf5, _utbotOut.condJ_tf6,
        _utbotOut.trigA, _utbotOut.trigB, _utbotOut.trigC, _utbotOut.trigD, _utbotOut.trigE,
        _utbotOut.trigF, _utbotOut.trigG, _utbotOut.trigH, _utbotOut.trigI, _utbotOut.trigJ,
        _utbotOut.trigger_price, _utbotOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END UT BOT LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//──────────────────────────────────────────────────────────────────────────────
// MACD LINE LOADER (V2)
// Only executes request.security() calls if lib_macdl_enabled is true
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_macdl_v2 = KB_TF_Out_V2.new()

if lib_macdl_enabled
    // Calculate MACD components
    float _macdl_fast = ta.ema(close, lib_macdl_fast)
    float _macdl_slow = ta.ema(close, lib_macdl_slow)
    float _macdl_macd = _macdl_fast - _macdl_slow
    float _macdl_sig  = ta.ema(_macdl_macd, lib_macdl_signal)

    // Fetch MACD and Signal for each TF
    [_macdl_m1, _macdl_s1] = request.security(syminfo.tickerid, _tf_res_v2(tf1),
        [_macdl_macd, _macdl_sig], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdl_m2, _macdl_s2] = request.security(syminfo.tickerid, _tf_res_v2(tf2),
        [_macdl_macd, _macdl_sig], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdl_m3, _macdl_s3] = request.security(syminfo.tickerid, _tf_res_v2(tf3),
        [_macdl_macd, _macdl_sig], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdl_m4, _macdl_s4] = request.security(syminfo.tickerid, _tf_res_v2(tf4),
        [_macdl_macd, _macdl_sig], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdl_m5, _macdl_s5] = request.security(syminfo.tickerid, _tf_res_v2(tf5),
        [_macdl_macd, _macdl_sig], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdl_m6, _macdl_s6] = request.security(syminfo.tickerid, _tf_res_v2(tf6),
        [_macdl_macd, _macdl_sig], barmerge.gaps_off, barmerge.lookahead_off)

    // Chart TF values for triggers
    float _macdl_m_chart = _macdl_macd
    float _macdl_s_chart = _macdl_sig
    float _macdl_m_prev = _macdl_macd[1]
    float _macdl_s_prev = _macdl_sig[1]

    // Call library's builder function
    tfMACDLine.TFModuleOutput _macdlOut = tfMACDLine.buildOutput(
        _macdl_m1, _macdl_s1,
        _macdl_m2, _macdl_s2,
        _macdl_m3, _macdl_s3,
        _macdl_m4, _macdl_s4,
        _macdl_m5, _macdl_s5,
        _macdl_m6, _macdl_s6,
        _macdl_m_chart, _macdl_s_chart, _macdl_m_prev, _macdl_s_prev,
        close
    )

    // Map to normalized V2 output
    lib_macdl_v2 := KB_TF_Out_V2.new(
        _macdlOut.tf1_label, _macdlOut.tf2_label, _macdlOut.tf3_label,
        _macdlOut.tf4_label, _macdlOut.tf5_label, _macdlOut.tf6_label,
        _macdlOut.condA_tf1, _macdlOut.condA_tf2, _macdlOut.condA_tf3,
        _macdlOut.condA_tf4, _macdlOut.condA_tf5, _macdlOut.condA_tf6,
        _macdlOut.condB_tf1, _macdlOut.condB_tf2, _macdlOut.condB_tf3,
        _macdlOut.condB_tf4, _macdlOut.condB_tf5, _macdlOut.condB_tf6,
        _macdlOut.condC_tf1, _macdlOut.condC_tf2, _macdlOut.condC_tf3,
        _macdlOut.condC_tf4, _macdlOut.condC_tf5, _macdlOut.condC_tf6,
        _macdlOut.condD_tf1, _macdlOut.condD_tf2, _macdlOut.condD_tf3,
        _macdlOut.condD_tf4, _macdlOut.condD_tf5, _macdlOut.condD_tf6,
        _macdlOut.condE_tf1, _macdlOut.condE_tf2, _macdlOut.condE_tf3,
        _macdlOut.condE_tf4, _macdlOut.condE_tf5, _macdlOut.condE_tf6,
        _macdlOut.condF_tf1, _macdlOut.condF_tf2, _macdlOut.condF_tf3,
        _macdlOut.condF_tf4, _macdlOut.condF_tf5, _macdlOut.condF_tf6,
        _macdlOut.condG_tf1, _macdlOut.condG_tf2, _macdlOut.condG_tf3,
        _macdlOut.condG_tf4, _macdlOut.condG_tf5, _macdlOut.condG_tf6,
        _macdlOut.condH_tf1, _macdlOut.condH_tf2, _macdlOut.condH_tf3,
        _macdlOut.condH_tf4, _macdlOut.condH_tf5, _macdlOut.condH_tf6,
        _macdlOut.condI_tf1, _macdlOut.condI_tf2, _macdlOut.condI_tf3,
        _macdlOut.condI_tf4, _macdlOut.condI_tf5, _macdlOut.condI_tf6,
        _macdlOut.condJ_tf1, _macdlOut.condJ_tf2, _macdlOut.condJ_tf3,
        _macdlOut.condJ_tf4, _macdlOut.condJ_tf5, _macdlOut.condJ_tf6,
        _macdlOut.trigA, _macdlOut.trigB, _macdlOut.trigC, _macdlOut.trigD, _macdlOut.trigE,
        _macdlOut.trigF, _macdlOut.trigG, _macdlOut.trigH, _macdlOut.trigI, _macdlOut.trigJ,
        _macdlOut.trigger_price, _macdlOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END MACD LINE LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//──────────────────────────────────────────────────────────────────────────────
// MACD HISTOGRAM LOADER (V2)
// Only executes request.security() calls if lib_macdh_enabled is true
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_macdh_v2 = KB_TF_Out_V2.new()

if lib_macdh_enabled
    // Calculate MACD components
    float _macdh_fast = ta.ema(close, lib_macdh_fast)
    float _macdh_slow = ta.ema(close, lib_macdh_slow)
    float _macdh_macd = _macdh_fast - _macdh_slow
    float _macdh_sig  = ta.ema(_macdh_macd, lib_macdh_signal)
    float _macdh_hist = _macdh_macd - _macdh_sig

    // Fetch Histogram and prev Histogram for each TF
    [_macdh_h1, _macdh_hp1] = request.security(syminfo.tickerid, _tf_res_v2(tf1),
        [_macdh_hist, _macdh_hist[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdh_h2, _macdh_hp2] = request.security(syminfo.tickerid, _tf_res_v2(tf2),
        [_macdh_hist, _macdh_hist[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdh_h3, _macdh_hp3] = request.security(syminfo.tickerid, _tf_res_v2(tf3),
        [_macdh_hist, _macdh_hist[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdh_h4, _macdh_hp4] = request.security(syminfo.tickerid, _tf_res_v2(tf4),
        [_macdh_hist, _macdh_hist[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdh_h5, _macdh_hp5] = request.security(syminfo.tickerid, _tf_res_v2(tf5),
        [_macdh_hist, _macdh_hist[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macdh_h6, _macdh_hp6] = request.security(syminfo.tickerid, _tf_res_v2(tf6),
        [_macdh_hist, _macdh_hist[1]], barmerge.gaps_off, barmerge.lookahead_off)

    // Chart TF values for triggers
    float _macdh_h_chart = _macdh_hist
    float _macdh_h_prev = _macdh_hist[1]
    float _macdh_h_prev2 = _macdh_hist[2]

    // Call library's builder function
    tfMACDHistogram.TFModuleOutput _macdhOut = tfMACDHistogram.buildOutput(
        _macdh_h1, _macdh_hp1,
        _macdh_h2, _macdh_hp2,
        _macdh_h3, _macdh_hp3,
        _macdh_h4, _macdh_hp4,
        _macdh_h5, _macdh_hp5,
        _macdh_h6, _macdh_hp6,
        _macdh_h_chart, _macdh_h_prev, _macdh_h_prev2,
        close
    )

    // Map to normalized V2 output
    lib_macdh_v2 := KB_TF_Out_V2.new(
        _macdhOut.tf1_label, _macdhOut.tf2_label, _macdhOut.tf3_label,
        _macdhOut.tf4_label, _macdhOut.tf5_label, _macdhOut.tf6_label,
        _macdhOut.condA_tf1, _macdhOut.condA_tf2, _macdhOut.condA_tf3,
        _macdhOut.condA_tf4, _macdhOut.condA_tf5, _macdhOut.condA_tf6,
        _macdhOut.condB_tf1, _macdhOut.condB_tf2, _macdhOut.condB_tf3,
        _macdhOut.condB_tf4, _macdhOut.condB_tf5, _macdhOut.condB_tf6,
        _macdhOut.condC_tf1, _macdhOut.condC_tf2, _macdhOut.condC_tf3,
        _macdhOut.condC_tf4, _macdhOut.condC_tf5, _macdhOut.condC_tf6,
        _macdhOut.condD_tf1, _macdhOut.condD_tf2, _macdhOut.condD_tf3,
        _macdhOut.condD_tf4, _macdhOut.condD_tf5, _macdhOut.condD_tf6,
        _macdhOut.condE_tf1, _macdhOut.condE_tf2, _macdhOut.condE_tf3,
        _macdhOut.condE_tf4, _macdhOut.condE_tf5, _macdhOut.condE_tf6,
        _macdhOut.condF_tf1, _macdhOut.condF_tf2, _macdhOut.condF_tf3,
        _macdhOut.condF_tf4, _macdhOut.condF_tf5, _macdhOut.condF_tf6,
        _macdhOut.condG_tf1, _macdhOut.condG_tf2, _macdhOut.condG_tf3,
        _macdhOut.condG_tf4, _macdhOut.condG_tf5, _macdhOut.condG_tf6,
        _macdhOut.condH_tf1, _macdhOut.condH_tf2, _macdhOut.condH_tf3,
        _macdhOut.condH_tf4, _macdhOut.condH_tf5, _macdhOut.condH_tf6,
        _macdhOut.condI_tf1, _macdhOut.condI_tf2, _macdhOut.condI_tf3,
        _macdhOut.condI_tf4, _macdhOut.condI_tf5, _macdhOut.condI_tf6,
        _macdhOut.condJ_tf1, _macdhOut.condJ_tf2, _macdhOut.condJ_tf3,
        _macdhOut.condJ_tf4, _macdhOut.condJ_tf5, _macdhOut.condJ_tf6,
        _macdhOut.trigA, _macdhOut.trigB, _macdhOut.trigC, _macdhOut.trigD, _macdhOut.trigE,
        _macdhOut.trigF, _macdhOut.trigG, _macdhOut.trigH, _macdhOut.trigI, _macdhOut.trigJ,
        _macdhOut.trigger_price, _macdhOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END MACD HISTOGRAM LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//──────────────────────────────────────────────────────────────────────────────
// SIMPLE MACD LOADER (V2)
// Only executes request.security() calls if lib_macds_enabled is true
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_macds_v2 = KB_TF_Out_V2.new()

if lib_macds_enabled
    // Calculate MACD components
    float _macds_fast = ta.ema(close, lib_macds_fast)
    float _macds_slow = ta.ema(close, lib_macds_slow)
    float _macds_macd = _macds_fast - _macds_slow
    float _macds_sig  = ta.ema(_macds_macd, lib_macds_signal)

    // Fetch MACD, Signal, prev MACD, prev Signal for each TF
    [_macds_m1, _macds_s1, _macds_mp1, _macds_sp1] = request.security(syminfo.tickerid, _tf_res_v2(tf1),
        [_macds_macd, _macds_sig, _macds_macd[1], _macds_sig[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macds_m2, _macds_s2, _macds_mp2, _macds_sp2] = request.security(syminfo.tickerid, _tf_res_v2(tf2),
        [_macds_macd, _macds_sig, _macds_macd[1], _macds_sig[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macds_m3, _macds_s3, _macds_mp3, _macds_sp3] = request.security(syminfo.tickerid, _tf_res_v2(tf3),
        [_macds_macd, _macds_sig, _macds_macd[1], _macds_sig[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macds_m4, _macds_s4, _macds_mp4, _macds_sp4] = request.security(syminfo.tickerid, _tf_res_v2(tf4),
        [_macds_macd, _macds_sig, _macds_macd[1], _macds_sig[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macds_m5, _macds_s5, _macds_mp5, _macds_sp5] = request.security(syminfo.tickerid, _tf_res_v2(tf5),
        [_macds_macd, _macds_sig, _macds_macd[1], _macds_sig[1]], barmerge.gaps_off, barmerge.lookahead_off)
    [_macds_m6, _macds_s6, _macds_mp6, _macds_sp6] = request.security(syminfo.tickerid, _tf_res_v2(tf6),
        [_macds_macd, _macds_sig, _macds_macd[1], _macds_sig[1]], barmerge.gaps_off, barmerge.lookahead_off)

    // Chart TF values for triggers
    float _macds_m_chart = _macds_macd
    float _macds_s_chart = _macds_sig
    float _macds_m_prev = _macds_macd[1]
    float _macds_s_prev = _macds_sig[1]

    // Call library's builder function
    tfMACDSimple.TFModuleOutput _macdsOut = tfMACDSimple.buildOutput(
        _macds_m1, _macds_s1, _macds_mp1, _macds_sp1,
        _macds_m2, _macds_s2, _macds_mp2, _macds_sp2,
        _macds_m3, _macds_s3, _macds_mp3, _macds_sp3,
        _macds_m4, _macds_s4, _macds_mp4, _macds_sp4,
        _macds_m5, _macds_s5, _macds_mp5, _macds_sp5,
        _macds_m6, _macds_s6, _macds_mp6, _macds_sp6,
        _macds_m_chart, _macds_s_chart, _macds_m_prev, _macds_s_prev,
        close
    )

    // Map to normalized V2 output
    lib_macds_v2 := KB_TF_Out_V2.new(
        _macdsOut.tf1_label, _macdsOut.tf2_label, _macdsOut.tf3_label,
        _macdsOut.tf4_label, _macdsOut.tf5_label, _macdsOut.tf6_label,
        _macdsOut.condA_tf1, _macdsOut.condA_tf2, _macdsOut.condA_tf3,
        _macdsOut.condA_tf4, _macdsOut.condA_tf5, _macdsOut.condA_tf6,
        _macdsOut.condB_tf1, _macdsOut.condB_tf2, _macdsOut.condB_tf3,
        _macdsOut.condB_tf4, _macdsOut.condB_tf5, _macdsOut.condB_tf6,
        _macdsOut.condC_tf1, _macdsOut.condC_tf2, _macdsOut.condC_tf3,
        _macdsOut.condC_tf4, _macdsOut.condC_tf5, _macdsOut.condC_tf6,
        _macdsOut.condD_tf1, _macdsOut.condD_tf2, _macdsOut.condD_tf3,
        _macdsOut.condD_tf4, _macdsOut.condD_tf5, _macdsOut.condD_tf6,
        _macdsOut.condE_tf1, _macdsOut.condE_tf2, _macdsOut.condE_tf3,
        _macdsOut.condE_tf4, _macdsOut.condE_tf5, _macdsOut.condE_tf6,
        _macdsOut.condF_tf1, _macdsOut.condF_tf2, _macdsOut.condF_tf3,
        _macdsOut.condF_tf4, _macdsOut.condF_tf5, _macdsOut.condF_tf6,
        _macdsOut.condG_tf1, _macdsOut.condG_tf2, _macdsOut.condG_tf3,
        _macdsOut.condG_tf4, _macdsOut.condG_tf5, _macdsOut.condG_tf6,
        _macdsOut.condH_tf1, _macdsOut.condH_tf2, _macdsOut.condH_tf3,
        _macdsOut.condH_tf4, _macdsOut.condH_tf5, _macdsOut.condH_tf6,
        _macdsOut.condI_tf1, _macdsOut.condI_tf2, _macdsOut.condI_tf3,
        _macdsOut.condI_tf4, _macdsOut.condI_tf5, _macdsOut.condI_tf6,
        _macdsOut.condJ_tf1, _macdsOut.condJ_tf2, _macdsOut.condJ_tf3,
        _macdsOut.condJ_tf4, _macdsOut.condJ_tf5, _macdsOut.condJ_tf6,
        _macdsOut.trigA, _macdsOut.trigB, _macdsOut.trigC, _macdsOut.trigD, _macdsOut.trigE,
        _macdsOut.trigF, _macdsOut.trigG, _macdsOut.trigH, _macdsOut.trigI, _macdsOut.trigJ,
        _macdsOut.trigger_price, _macdsOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END SIMPLE MACD LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//──────────────────────────────────────────────────────────────────────────────
// SWING 123 LOADER (V2)
// Only executes request.security() calls if lib_swing_enabled is true
// Calculates 1-2-3 patterns on each TF and passes boolean flags to library
//──────────────────────────────────────────────────────────────────────────────

// Initialize empty output
var KB_TF_Out_V2 lib_swing_v2 = KB_TF_Out_V2.new()

// Pattern calculation functions (must be outside if block for request.security)
// BC2: Lower low BUT closes above prior close
_sw_bc2() => low < low[1] and close > close[1]
// BC3: After BC2, closes above prior high
_sw_bc3() => low[1] < low[2] and close[1] > close[2] and close > high[1]
// XC2: Higher high BUT closes below prior close
_sw_xc2() => high > high[1] and close < close[1]
// XC3: After XC2, closes below prior low
_sw_xc3() => high[1] > high[2] and close[1] < close[2] and close < low[1]
// Recent bullish: BC2 or BC3 within last 3 bars
_sw_rbull() => _sw_bc2() or _sw_bc2()[1] or _sw_bc2()[2] or _sw_bc3() or _sw_bc3()[1] or _sw_bc3()[2]
// Recent bearish: XC2 or XC3 within last 3 bars
_sw_rbear() => _sw_xc2() or _sw_xc2()[1] or _sw_xc2()[2] or _sw_xc3() or _sw_xc3()[1] or _sw_xc3()[2]

if lib_swing_enabled
    // Fetch pattern flags for each TF (6 bools per TF = 6 security calls)
    [_sw_bc2_1, _sw_bc3_1, _sw_xc2_1, _sw_xc3_1, _sw_rb_1, _sw_rx_1] = request.security(syminfo.tickerid, _tf_res_v2(tf1),
        [_sw_bc2(), _sw_bc3(), _sw_xc2(), _sw_xc3(), _sw_rbull(), _sw_rbear()], barmerge.gaps_off, barmerge.lookahead_off)
    [_sw_bc2_2, _sw_bc3_2, _sw_xc2_2, _sw_xc3_2, _sw_rb_2, _sw_rx_2] = request.security(syminfo.tickerid, _tf_res_v2(tf2),
        [_sw_bc2(), _sw_bc3(), _sw_xc2(), _sw_xc3(), _sw_rbull(), _sw_rbear()], barmerge.gaps_off, barmerge.lookahead_off)
    [_sw_bc2_3, _sw_bc3_3, _sw_xc2_3, _sw_xc3_3, _sw_rb_3, _sw_rx_3] = request.security(syminfo.tickerid, _tf_res_v2(tf3),
        [_sw_bc2(), _sw_bc3(), _sw_xc2(), _sw_xc3(), _sw_rbull(), _sw_rbear()], barmerge.gaps_off, barmerge.lookahead_off)
    [_sw_bc2_4, _sw_bc3_4, _sw_xc2_4, _sw_xc3_4, _sw_rb_4, _sw_rx_4] = request.security(syminfo.tickerid, _tf_res_v2(tf4),
        [_sw_bc2(), _sw_bc3(), _sw_xc2(), _sw_xc3(), _sw_rbull(), _sw_rbear()], barmerge.gaps_off, barmerge.lookahead_off)
    [_sw_bc2_5, _sw_bc3_5, _sw_xc2_5, _sw_xc3_5, _sw_rb_5, _sw_rx_5] = request.security(syminfo.tickerid, _tf_res_v2(tf5),
        [_sw_bc2(), _sw_bc3(), _sw_xc2(), _sw_xc3(), _sw_rbull(), _sw_rbear()], barmerge.gaps_off, barmerge.lookahead_off)
    [_sw_bc2_6, _sw_bc3_6, _sw_xc2_6, _sw_xc3_6, _sw_rb_6, _sw_rx_6] = request.security(syminfo.tickerid, _tf_res_v2(tf6),
        [_sw_bc2(), _sw_bc3(), _sw_xc2(), _sw_xc3(), _sw_rbull(), _sw_rbear()], barmerge.gaps_off, barmerge.lookahead_off)

    // Chart TF patterns for triggers
    bool _sw_bc2_chart = _sw_bc2()
    bool _sw_bc3_chart = _sw_bc3()
    bool _sw_xc2_chart = _sw_xc2()
    bool _sw_xc3_chart = _sw_xc3()

    // Call library's builder function with boolean flags
    tfSwing123.TFModuleOutput _swingOut = tfSwing123.buildOutput(
        _sw_bc2_1, _sw_bc3_1, _sw_xc2_1, _sw_xc3_1, _sw_rb_1, _sw_rx_1,
        _sw_bc2_2, _sw_bc3_2, _sw_xc2_2, _sw_xc3_2, _sw_rb_2, _sw_rx_2,
        _sw_bc2_3, _sw_bc3_3, _sw_xc2_3, _sw_xc3_3, _sw_rb_3, _sw_rx_3,
        _sw_bc2_4, _sw_bc3_4, _sw_xc2_4, _sw_xc3_4, _sw_rb_4, _sw_rx_4,
        _sw_bc2_5, _sw_bc3_5, _sw_xc2_5, _sw_xc3_5, _sw_rb_5, _sw_rx_5,
        _sw_bc2_6, _sw_bc3_6, _sw_xc2_6, _sw_xc3_6, _sw_rb_6, _sw_rx_6,
        _sw_bc2_chart, _sw_bc3_chart, _sw_xc2_chart, _sw_xc3_chart,
        close
    )

    // Map to normalized V2 output
    lib_swing_v2 := KB_TF_Out_V2.new(
        _swingOut.tf1_label, _swingOut.tf2_label, _swingOut.tf3_label,
        _swingOut.tf4_label, _swingOut.tf5_label, _swingOut.tf6_label,
        _swingOut.condA_tf1, _swingOut.condA_tf2, _swingOut.condA_tf3,
        _swingOut.condA_tf4, _swingOut.condA_tf5, _swingOut.condA_tf6,
        _swingOut.condB_tf1, _swingOut.condB_tf2, _swingOut.condB_tf3,
        _swingOut.condB_tf4, _swingOut.condB_tf5, _swingOut.condB_tf6,
        _swingOut.condC_tf1, _swingOut.condC_tf2, _swingOut.condC_tf3,
        _swingOut.condC_tf4, _swingOut.condC_tf5, _swingOut.condC_tf6,
        _swingOut.condD_tf1, _swingOut.condD_tf2, _swingOut.condD_tf3,
        _swingOut.condD_tf4, _swingOut.condD_tf5, _swingOut.condD_tf6,
        _swingOut.condE_tf1, _swingOut.condE_tf2, _swingOut.condE_tf3,
        _swingOut.condE_tf4, _swingOut.condE_tf5, _swingOut.condE_tf6,
        _swingOut.condF_tf1, _swingOut.condF_tf2, _swingOut.condF_tf3,
        _swingOut.condF_tf4, _swingOut.condF_tf5, _swingOut.condF_tf6,
        _swingOut.condG_tf1, _swingOut.condG_tf2, _swingOut.condG_tf3,
        _swingOut.condG_tf4, _swingOut.condG_tf5, _swingOut.condG_tf6,
        _swingOut.condH_tf1, _swingOut.condH_tf2, _swingOut.condH_tf3,
        _swingOut.condH_tf4, _swingOut.condH_tf5, _swingOut.condH_tf6,
        _swingOut.condI_tf1, _swingOut.condI_tf2, _swingOut.condI_tf3,
        _swingOut.condI_tf4, _swingOut.condI_tf5, _swingOut.condI_tf6,
        _swingOut.condJ_tf1, _swingOut.condJ_tf2, _swingOut.condJ_tf3,
        _swingOut.condJ_tf4, _swingOut.condJ_tf5, _swingOut.condJ_tf6,
        _swingOut.trigA, _swingOut.trigB, _swingOut.trigC, _swingOut.trigD, _swingOut.trigE,
        _swingOut.trigF, _swingOut.trigG, _swingOut.trigH, _swingOut.trigI, _swingOut.trigJ,
        _swingOut.trigger_price, _swingOut.trigger_label
    )

//──────────────────────────────────────────────────────────────────────────────
// END SWING 123 LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────

//──────────────────────────────────────────────────────────────────────────────
// TOP VWAP LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────
// Calculates Daily, Weekly, and Monthly anchored VWAPs directly on chart TF.
// No request.security needed since all VWAPs are calculated on current chart.
//──────────────────────────────────────────────────────────────────────────────

// Output variables for VWAP zone labels
var string lib_vwap_D_zone = "na"
var string lib_vwap_W_zone = "na"
var string lib_vwap_M_zone = "na"

// VWAP values for potential plotting/export
var float _vwap_D_val = na
var float _vwap_W_val = na
var float _vwap_M_val = na
var float _vwap_D_sd = na
var float _vwap_W_sd = na
var float _vwap_M_sd = na

if lib_vwap_enabled
    // Calculate anchored VWAPs directly on chart timeframe
    [_vwap_D, _sd_D] = _kb_calcVWAP()    // Daily reset
    [_vwap_W, _sd_W] = _kb_calcVWAP_W()  // Weekly reset
    [_vwap_M, _sd_M] = _kb_calcVWAP_M()  // Monthly reset

    // Store values
    _vwap_D_val := _vwap_D
    _vwap_W_val := _vwap_W
    _vwap_M_val := _vwap_M
    _vwap_D_sd := _sd_D
    _vwap_W_sd := _sd_W
    _vwap_M_sd := _sd_M

    // Determine zone labels based on current price vs each anchored VWAP
    lib_vwap_D_zone := _kb_vwapZoneLabel(close, _vwap_D, _sd_D, lib_vwap_band1, lib_vwap_band2)
    lib_vwap_W_zone := _kb_vwapZoneLabel(close, _vwap_W, _sd_W, lib_vwap_band1, lib_vwap_band2)
    lib_vwap_M_zone := _kb_vwapZoneLabel(close, _vwap_M, _sd_M, lib_vwap_band1, lib_vwap_band2)

//──────────────────────────────────────────────────────────────────────────────
// END TOP VWAP LOADER (V2)
//──────────────────────────────────────────────────────────────────────────────


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// V2 LIBRARY OUTPUTS (Placeholder declarations for downstream compatibility)
// NOTE: Legacy Side Module 1/2 loaders removed in v2.0 transition
// Real v2 loaders are above (lib_ema_v2, lib_rvol_v2, etc.)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Placeholder outputs for compatibility with downstream blocks
// These will be replaced with proper v2 library routing in future iterations
var KB_TF_Out_V2 side1_v2 = KB_TF_Out_V2.new()
var KB_TF_Out_V2 side2_v2 = KB_TF_Out_V2.new()

// Legacy compatibility flags (disabled since legacy modules removed)
bool _side1_moduleActive = false
bool _side2_moduleActive = false

// Legacy loaders were removed here - see v1.1 backup in legacy/ folder


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 8.4 OUTPUT BRIDGE FOR DOWNSTREAM BLOCKS
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//
// These stable variables are consumed by:
//   • Block 8 (RAW TRIGGER ROUTING)
//   • Block 9 (CONFLUENCE ENGINE)
//   • Block 12 (Side Table Renderer)
//
// Uses V2 structure with 10 conditions (A-J) per TF and 10 triggers (A-J).
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Helper: map condition source text to an index slot (0-9 for A-J)
// Supports: Generic (Cond A-J), EMA Stack (SML/LMS/etc), RVOL (RV!/++/+/=/-)
// UT Bot (Bull/Bear), Swing123 (BC2/BC3/XC2/XC3/B↑/X↓), MACD Line (M>S+/M>S-/M<S-/M<S+)
// MACD Histogram (H+↑/H+↓/H-↓/H-↑), Simple MACD (M>S↑/M>S↓/M<S↓/M<S↑)
_kb_mapCondSource(string src) => src == "Cond A" ? 0 : src == "Cond B" ? 1 : src == "Cond C" ? 2 : src == "Cond D" ? 3 : src == "Cond E" ? 4 : src == "Cond F" ? 5 : src == "Cond G" ? 6 : src == "Cond H" ? 7 : src == "Cond I" ? 8 : src == "Cond J" ? 9 : src == "SML (Bull)" ? 0 : src == "LMS (Bear)" ? 1 : src == "SLM" ? 2 : src == "MSL" ? 3 : src == "MLS" ? 4 : src == "LSM" ? 5 : src == "RV!" ? 0 : src == "RV++" ? 1 : src == "RV+" ? 2 : src == "RV=" ? 3 : src == "RV-" ? 4 : src == "Bull" ? 0 : src == "Bear" ? 1 : src == "BC2" ? 0 : src == "BC3" ? 1 : src == "XC2" ? 2 : src == "XC3" ? 3 : src == "B↑" ? 4 : src == "X↓" ? 5 : src == "M>S+" ? 0 : src == "M>S-" ? 1 : src == "M<S-" ? 2 : src == "M<S+" ? 3 : src == "H+↑" ? 0 : src == "H+↓" ? 1 : src == "H-↓" ? 2 : src == "H-↑" ? 3 : src == "M>S↑" ? 0 : src == "M>S↓" ? 1 : src == "M<S↓" ? 2 : src == "M<S↑" ? 3 : -1

// Helper: get trigger by index from V2 output
_kb_getTrigger(KB_TF_Out_V2 v2, int idx) =>
    idx == 0 ? v2.trigA : idx == 1 ? v2.trigB : idx == 2 ? v2.trigC : idx == 3 ? v2.trigD : idx == 4 ? v2.trigE : idx == 5 ? v2.trigF : idx == 6 ? v2.trigG : idx == 7 ? v2.trigH : idx == 8 ? v2.trigI : idx == 9 ? v2.trigJ : false

// Helper: get condition for a specific TF by condition index
_kb_getCondTF1(KB_TF_Out_V2 v2, int idx) => idx == 0 ? v2.condA_tf1 : idx == 1 ? v2.condB_tf1 : idx == 2 ? v2.condC_tf1 : idx == 3 ? v2.condD_tf1 : idx == 4 ? v2.condE_tf1 : idx == 5 ? v2.condF_tf1 : idx == 6 ? v2.condG_tf1 : idx == 7 ? v2.condH_tf1 : idx == 8 ? v2.condI_tf1 : idx == 9 ? v2.condJ_tf1 : false
_kb_getCondTF2(KB_TF_Out_V2 v2, int idx) => idx == 0 ? v2.condA_tf2 : idx == 1 ? v2.condB_tf2 : idx == 2 ? v2.condC_tf2 : idx == 3 ? v2.condD_tf2 : idx == 4 ? v2.condE_tf2 : idx == 5 ? v2.condF_tf2 : idx == 6 ? v2.condG_tf2 : idx == 7 ? v2.condH_tf2 : idx == 8 ? v2.condI_tf2 : idx == 9 ? v2.condJ_tf2 : false
_kb_getCondTF3(KB_TF_Out_V2 v2, int idx) => idx == 0 ? v2.condA_tf3 : idx == 1 ? v2.condB_tf3 : idx == 2 ? v2.condC_tf3 : idx == 3 ? v2.condD_tf3 : idx == 4 ? v2.condE_tf3 : idx == 5 ? v2.condF_tf3 : idx == 6 ? v2.condG_tf3 : idx == 7 ? v2.condH_tf3 : idx == 8 ? v2.condI_tf3 : idx == 9 ? v2.condJ_tf3 : false
_kb_getCondTF4(KB_TF_Out_V2 v2, int idx) => idx == 0 ? v2.condA_tf4 : idx == 1 ? v2.condB_tf4 : idx == 2 ? v2.condC_tf4 : idx == 3 ? v2.condD_tf4 : idx == 4 ? v2.condE_tf4 : idx == 5 ? v2.condF_tf4 : idx == 6 ? v2.condG_tf4 : idx == 7 ? v2.condH_tf4 : idx == 8 ? v2.condI_tf4 : idx == 9 ? v2.condJ_tf4 : false
_kb_getCondTF5(KB_TF_Out_V2 v2, int idx) => idx == 0 ? v2.condA_tf5 : idx == 1 ? v2.condB_tf5 : idx == 2 ? v2.condC_tf5 : idx == 3 ? v2.condD_tf5 : idx == 4 ? v2.condE_tf5 : idx == 5 ? v2.condF_tf5 : idx == 6 ? v2.condG_tf5 : idx == 7 ? v2.condH_tf5 : idx == 8 ? v2.condI_tf5 : idx == 9 ? v2.condJ_tf5 : false
_kb_getCondTF6(KB_TF_Out_V2 v2, int idx) => idx == 0 ? v2.condA_tf6 : idx == 1 ? v2.condB_tf6 : idx == 2 ? v2.condC_tf6 : idx == 3 ? v2.condD_tf6 : idx == 4 ? v2.condE_tf6 : idx == 5 ? v2.condF_tf6 : idx == 6 ? v2.condG_tf6 : idx == 7 ? v2.condH_tf6 : idx == 8 ? v2.condI_tf6 : idx == 9 ? v2.condJ_tf6 : false

// Trigger metadata (shared across all triggers)
float  _side1_triggerPrice = _side1_moduleActive ? side1_v2.trigger_price : na
string _side1_triggerLabel = _side1_moduleActive ? side1_v2.trigger_label : ""

// Per-TF labels (from V2 structure)
string _side1_tf1_label = side1_v2.tf1_label
string _side1_tf2_label = side1_v2.tf2_label
string _side1_tf3_label = side1_v2.tf3_label
string _side1_tf4_label = side1_v2.tf4_label
string _side1_tf5_label = side1_v2.tf5_label
string _side1_tf6_label = side1_v2.tf6_label

// Side Module 2 output bridge variables
float  _side2_triggerPrice = _side2_moduleActive ? side2_v2.trigger_price : na
string _side2_triggerLabel = _side2_moduleActive ? side2_v2.trigger_label : ""

string _side2_tf1_label = side2_v2.tf1_label
string _side2_tf2_label = side2_v2.tf2_label
string _side2_tf3_label = side2_v2.tf3_label
string _side2_tf4_label = side2_v2.tf4_label
string _side2_tf5_label = side2_v2.tf5_label
string _side2_tf6_label = side2_v2.tf6_label


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 8. RAW TRIGGER ROUTING (V2 Library-Centric)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// Each v2 library contributes triggers based on its own input configuration.
// Combined triggers: OR logic across all enabled libraries.
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Helper: map trigger source text to an index slot (0-9 for A-J)
// Supports: Generic (Trigger A-J), EMA Stack (S>M Cross, etc), RVOL (Vol Spike/Extreme/Fade)
// UT Bot (Buy/Sell), Swing123 (BC2/BC3/XC2/XC3), MACD (Bullish/Bearish Cross, Zero Cross Up/Down)
// MACD Histogram (Flip Bullish/Bearish, Shift Up/Down)
_kb_mapTriggerSource(string src) => src == "Trigger A" ? 0 : src == "Trigger B" ? 1 : src == "Trigger C" ? 2 : src == "Trigger D" ? 3 : src == "Trigger E" ? 4 : src == "Trigger F" ? 5 : src == "Trigger G" ? 6 : src == "Trigger H" ? 7 : src == "Trigger I" ? 8 : src == "Trigger J" ? 9 : src == "S > M Cross" ? 0 : src == "S < M Cross" ? 1 : src == "S > L Cross" ? 2 : src == "S < L Cross" ? 3 : src == "M > L Cross" ? 4 : src == "M < L Cross" ? 5 : src == "Vol Spike" ? 0 : src == "Vol Extreme" ? 1 : src == "Vol Fade" ? 2 : src == "Buy" ? 0 : src == "Sell" ? 1 : src == "BC2" ? 0 : src == "BC3" ? 1 : src == "XC2" ? 2 : src == "XC3" ? 3 : src == "Bullish Cross" ? 0 : src == "Bearish Cross" ? 1 : src == "Zero Cross Up" ? 2 : src == "Zero Cross Down" ? 3 : src == "Flip Bullish" ? 0 : src == "Flip Bearish" ? 1 : src == "Shift Up" ? 2 : src == "Shift Down" ? 3 : -1

// Helper functions for signal-type dropdown
_kb_sigRawEnabled(string t) => t == "Raw Only" or t == "Both"
_kb_sigPosEnabled(string t) => t == "Position Only" or t == "Both"

// Initialize combined triggers (will be OR'd from all enabled libraries)
bool rawLongEntry  = false
bool rawLongExit   = false
bool rawShortEntry = false
bool rawShortExit  = false

bool markLongEntry  = false
bool markLongExit   = false
bool markShortEntry = false
bool markShortExit  = false

//──────────────────────────────────────────────────────────────────────────────
// EMA STACK TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_ema_enabled
    // Map library-specific trigger sources to indices
    int _ema_LE_idx = _kb_mapTriggerSource(lib_ema_LE_source)
    int _ema_SE_idx = _kb_mapTriggerSource(lib_ema_SE_source)
    int _ema_LX_idx = _kb_mapTriggerSource(lib_ema_LX_source)
    int _ema_SX_idx = _kb_mapTriggerSource(lib_ema_SX_source)

    // Get triggers from the library output
    bool _ema_LE_trig = _ema_LE_idx >= 0 and _kb_getTrigger(lib_ema_v2, _ema_LE_idx)
    bool _ema_SE_trig = _ema_SE_idx >= 0 and _kb_getTrigger(lib_ema_v2, _ema_SE_idx)
    bool _ema_LX_trig = _ema_LX_idx >= 0 and _kb_getTrigger(lib_ema_v2, _ema_LX_idx)
    bool _ema_SX_trig = _ema_SX_idx >= 0 and _kb_getTrigger(lib_ema_v2, _ema_SX_idx)

    // Apply signal type filtering and combine
    if lib_ema_LE_enable and _ema_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_ema_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_ema_LE_sigType)
    if lib_ema_SE_enable and _ema_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_ema_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_ema_SE_sigType)
    if lib_ema_LX_enable and _ema_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_ema_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_ema_LX_sigType)
    if lib_ema_SX_enable and _ema_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_ema_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_ema_SX_sigType)

//──────────────────────────────────────────────────────────────────────────────
// RVOL TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_rvol_enabled
    // Map library-specific trigger sources to indices
    int _rvol_LE_idx = _kb_mapTriggerSource(lib_rvol_LE_source)
    int _rvol_SE_idx = _kb_mapTriggerSource(lib_rvol_SE_source)
    int _rvol_LX_idx = _kb_mapTriggerSource(lib_rvol_LX_source)
    int _rvol_SX_idx = _kb_mapTriggerSource(lib_rvol_SX_source)

    // Get triggers from the library output
    bool _rvol_LE_trig = _rvol_LE_idx >= 0 and _kb_getTrigger(lib_rvol_v2, _rvol_LE_idx)
    bool _rvol_SE_trig = _rvol_SE_idx >= 0 and _kb_getTrigger(lib_rvol_v2, _rvol_SE_idx)
    bool _rvol_LX_trig = _rvol_LX_idx >= 0 and _kb_getTrigger(lib_rvol_v2, _rvol_LX_idx)
    bool _rvol_SX_trig = _rvol_SX_idx >= 0 and _kb_getTrigger(lib_rvol_v2, _rvol_SX_idx)

    // Apply signal type filtering and combine
    if lib_rvol_LE_enable and _rvol_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_rvol_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_rvol_LE_sigType)
    if lib_rvol_SE_enable and _rvol_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_rvol_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_rvol_SE_sigType)
    if lib_rvol_LX_enable and _rvol_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_rvol_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_rvol_LX_sigType)
    if lib_rvol_SX_enable and _rvol_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_rvol_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_rvol_SX_sigType)

//──────────────────────────────────────────────────────────────────────────────
// UT BOT TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_utbot_enabled
    int _utbot_LE_idx = _kb_mapTriggerSource(lib_utbot_LE_source)
    int _utbot_SE_idx = _kb_mapTriggerSource(lib_utbot_SE_source)
    int _utbot_LX_idx = _kb_mapTriggerSource(lib_utbot_LX_source)
    int _utbot_SX_idx = _kb_mapTriggerSource(lib_utbot_SX_source)

    bool _utbot_LE_trig = _utbot_LE_idx >= 0 and _kb_getTrigger(lib_utbot_v2, _utbot_LE_idx)
    bool _utbot_SE_trig = _utbot_SE_idx >= 0 and _kb_getTrigger(lib_utbot_v2, _utbot_SE_idx)
    bool _utbot_LX_trig = _utbot_LX_idx >= 0 and _kb_getTrigger(lib_utbot_v2, _utbot_LX_idx)
    bool _utbot_SX_trig = _utbot_SX_idx >= 0 and _kb_getTrigger(lib_utbot_v2, _utbot_SX_idx)

    if lib_utbot_LE_enable and _utbot_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_utbot_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_utbot_LE_sigType)
    if lib_utbot_SE_enable and _utbot_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_utbot_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_utbot_SE_sigType)
    if lib_utbot_LX_enable and _utbot_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_utbot_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_utbot_LX_sigType)
    if lib_utbot_SX_enable and _utbot_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_utbot_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_utbot_SX_sigType)

//──────────────────────────────────────────────────────────────────────────────
// SWING 123 TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_swing_enabled
    int _swing_LE_idx = _kb_mapTriggerSource(lib_swing_LE_source)
    int _swing_SE_idx = _kb_mapTriggerSource(lib_swing_SE_source)
    int _swing_LX_idx = _kb_mapTriggerSource(lib_swing_LX_source)
    int _swing_SX_idx = _kb_mapTriggerSource(lib_swing_SX_source)

    bool _swing_LE_trig = _swing_LE_idx >= 0 and _kb_getTrigger(lib_swing_v2, _swing_LE_idx)
    bool _swing_SE_trig = _swing_SE_idx >= 0 and _kb_getTrigger(lib_swing_v2, _swing_SE_idx)
    bool _swing_LX_trig = _swing_LX_idx >= 0 and _kb_getTrigger(lib_swing_v2, _swing_LX_idx)
    bool _swing_SX_trig = _swing_SX_idx >= 0 and _kb_getTrigger(lib_swing_v2, _swing_SX_idx)

    if lib_swing_LE_enable and _swing_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_swing_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_swing_LE_sigType)
    if lib_swing_SE_enable and _swing_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_swing_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_swing_SE_sigType)
    if lib_swing_LX_enable and _swing_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_swing_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_swing_LX_sigType)
    if lib_swing_SX_enable and _swing_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_swing_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_swing_SX_sigType)

//──────────────────────────────────────────────────────────────────────────────
// MACD LINE TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_macdl_enabled
    int _macdl_LE_idx = _kb_mapTriggerSource(lib_macdl_LE_source)
    int _macdl_SE_idx = _kb_mapTriggerSource(lib_macdl_SE_source)
    int _macdl_LX_idx = _kb_mapTriggerSource(lib_macdl_LX_source)
    int _macdl_SX_idx = _kb_mapTriggerSource(lib_macdl_SX_source)

    bool _macdl_LE_trig = _macdl_LE_idx >= 0 and _kb_getTrigger(lib_macdl_v2, _macdl_LE_idx)
    bool _macdl_SE_trig = _macdl_SE_idx >= 0 and _kb_getTrigger(lib_macdl_v2, _macdl_SE_idx)
    bool _macdl_LX_trig = _macdl_LX_idx >= 0 and _kb_getTrigger(lib_macdl_v2, _macdl_LX_idx)
    bool _macdl_SX_trig = _macdl_SX_idx >= 0 and _kb_getTrigger(lib_macdl_v2, _macdl_SX_idx)

    if lib_macdl_LE_enable and _macdl_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_macdl_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_macdl_LE_sigType)
    if lib_macdl_SE_enable and _macdl_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_macdl_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_macdl_SE_sigType)
    if lib_macdl_LX_enable and _macdl_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_macdl_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_macdl_LX_sigType)
    if lib_macdl_SX_enable and _macdl_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_macdl_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_macdl_SX_sigType)

//──────────────────────────────────────────────────────────────────────────────
// MACD HISTOGRAM TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_macdh_enabled
    int _macdh_LE_idx = _kb_mapTriggerSource(lib_macdh_LE_source)
    int _macdh_SE_idx = _kb_mapTriggerSource(lib_macdh_SE_source)
    int _macdh_LX_idx = _kb_mapTriggerSource(lib_macdh_LX_source)
    int _macdh_SX_idx = _kb_mapTriggerSource(lib_macdh_SX_source)

    bool _macdh_LE_trig = _macdh_LE_idx >= 0 and _kb_getTrigger(lib_macdh_v2, _macdh_LE_idx)
    bool _macdh_SE_trig = _macdh_SE_idx >= 0 and _kb_getTrigger(lib_macdh_v2, _macdh_SE_idx)
    bool _macdh_LX_trig = _macdh_LX_idx >= 0 and _kb_getTrigger(lib_macdh_v2, _macdh_LX_idx)
    bool _macdh_SX_trig = _macdh_SX_idx >= 0 and _kb_getTrigger(lib_macdh_v2, _macdh_SX_idx)

    if lib_macdh_LE_enable and _macdh_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_macdh_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_macdh_LE_sigType)
    if lib_macdh_SE_enable and _macdh_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_macdh_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_macdh_SE_sigType)
    if lib_macdh_LX_enable and _macdh_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_macdh_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_macdh_LX_sigType)
    if lib_macdh_SX_enable and _macdh_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_macdh_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_macdh_SX_sigType)

//──────────────────────────────────────────────────────────────────────────────
// SIMPLE MACD TRIGGER ROUTING
//──────────────────────────────────────────────────────────────────────────────
if lib_macds_enabled
    int _macds_LE_idx = _kb_mapTriggerSource(lib_macds_LE_source)
    int _macds_SE_idx = _kb_mapTriggerSource(lib_macds_SE_source)
    int _macds_LX_idx = _kb_mapTriggerSource(lib_macds_LX_source)
    int _macds_SX_idx = _kb_mapTriggerSource(lib_macds_SX_source)

    bool _macds_LE_trig = _macds_LE_idx >= 0 and _kb_getTrigger(lib_macds_v2, _macds_LE_idx)
    bool _macds_SE_trig = _macds_SE_idx >= 0 and _kb_getTrigger(lib_macds_v2, _macds_SE_idx)
    bool _macds_LX_trig = _macds_LX_idx >= 0 and _kb_getTrigger(lib_macds_v2, _macds_LX_idx)
    bool _macds_SX_trig = _macds_SX_idx >= 0 and _kb_getTrigger(lib_macds_v2, _macds_SX_idx)

    if lib_macds_LE_enable and _macds_LE_trig
        rawLongEntry  := rawLongEntry  or _kb_sigPosEnabled(lib_macds_LE_sigType)
        markLongEntry := markLongEntry or _kb_sigRawEnabled(lib_macds_LE_sigType)
    if lib_macds_SE_enable and _macds_SE_trig
        rawShortEntry  := rawShortEntry  or _kb_sigPosEnabled(lib_macds_SE_sigType)
        markShortEntry := markShortEntry or _kb_sigRawEnabled(lib_macds_SE_sigType)
    if lib_macds_LX_enable and _macds_LX_trig
        rawLongExit  := rawLongExit  or _kb_sigPosEnabled(lib_macds_LX_sigType)
        markLongExit := markLongExit or _kb_sigRawEnabled(lib_macds_LX_sigType)
    if lib_macds_SX_enable and _macds_SX_trig
        rawShortExit  := rawShortExit  or _kb_sigPosEnabled(lib_macds_SX_sigType)
        markShortExit := markShortExit or _kb_sigRawEnabled(lib_macds_SX_sigType)

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 9. CONFLUENCE ENGINE
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// KevBot Toolkit v1.0 — Confluence Engine Module
// Standalone engine fragment – to be integrated into KevBot_Main
// Pine v6 compatible, no external imports required

//@version=6
// NOTE: Do NOT use this as a standalone script on TradingView.
// Copy the engine pieces into your main KevBot Toolkit script.

//──────────────────────────────────────────────────────────────────────────────
// ConfluenceResult type
//──────────────────────────────────────────────────────────────────────────────

// Encapsulates the final confluence state for long/short directions.
// longScore / shortScore  → total TH score
// longReqOk / shortReqOk  → all required conditions satisfied?
// longGrade / shortGrade  → "A" / "B" / "C" / "None" / "Fail"

type ConfluenceResult
    float  longScore
    float  shortScore
    bool   longReqOk
    bool   shortReqOk
    string longGrade
    string shortGrade

//──────────────────────────────────────────────────────────────────────────────
// Helpers for Top Module evaluation
//──────────────────────────────────────────────────────────────────────────────

// Map a Top Module Source selector ("Output A".."Output D") to a value.
// The caller passes the four raw outputs explicitly to keep this engine
// independent of any specific library type.
getTopSourceValue(string src, float outA, float outB, float outC, float outD) =>
    float v = na
    if   src == "Output A"
        v := outA
    else if src == "Output B"
        v := outB
    else if src == "Output C"
        v := outC
    else if src == "Output D"
        v := outD
    v

// Evaluate a single value against Mode + Value A/B settings.
// Modes: Boolean, Greater Than, Less Than, Between, Equals, Library Default

evalTopCondition(string mode, float v, float a, float b) =>
    bool passed = false
    if mode == "Boolean"
        passed := v != 0.0
    else if mode == "Greater Than"
        passed := v > a
    else if mode == "Less Than"
        passed := v < a
    else if mode == "Between"
        float lo = math.min(a, b)
        float hi = math.max(a, b)
        passed := v >= lo and v <= hi
    else if mode == "Equals"
        passed := v == a
    else
        // "Library Default" → treat non‑zero as true
        passed := v != 0.0
    passed

// Process a single Top output row (O1–O4).
// Returns: [addLong, addShort, reqLongOk, reqShortOk]

applyTopOutput(bool moduleActive, bool enabled, bool required, string dir, string mode, string src, float valA, float valB, int thScore, float outA, float outB, float outC, float outD) =>
    float addLong  = 0.0
    float addShort = 0.0
    bool  reqLong  = true
    bool  reqShort = true

    if moduleActive and enabled and src != "None"
        float v      = getTopSourceValue(src, outA, outB, outC, outD)
        bool  passes = evalTopCondition(mode, v, valA, valB)
        bool  useLong  = dir == "Both" or dir == "Long"
        bool  useShort = dir == "Both" or dir == "Short"

        if passes
            if useLong
                addLong := thScore
            if useShort
                addShort := thScore

        if required
            if useLong and not passes
                reqLong := false
            if useShort and not passes
                reqShort := false

    [addLong, addShort, reqLong, reqShort]

//──────────────────────────────────────────────────────────────────────────────
// Top Module 1 – Confluence Aggregation
//──────────────────────────────────────────────────────────────────────────────

// This function expects the main script to pass all Top1 config + outputs.
// It returns partial Top confluence that will later be combined with Side TF
// confluence into a ConfluenceResult.

calcTopConfluence(bool topEnabled, string topLibraryName, float outA, float outB, float outC, float outD, bool o1_enabled, bool o1_required, string o1_dir, string o1_mode, string o1_source, float o1_valA, float o1_valB, int o1_score, bool o2_enabled, bool o2_required, string o2_dir, string o2_mode, string o2_source, float o2_valA, float o2_valB, int o2_score, bool o3_enabled, bool o3_required, string o3_dir, string o3_mode, string o3_source, float o3_valA, float o3_valB, int o3_score, bool o4_enabled, bool o4_required, string o4_dir, string o4_mode, string o4_source, float o4_valA, float o4_valB, int o4_score) =>
    bool  active        = topEnabled and topLibraryName != "None"
    float topLongScore  = 0.0
    float topShortScore = 0.0
    bool  reqLongOk     = true
    bool  reqShortOk    = true

    // O1
    [o1L, o1S, o1ReqL, o1ReqS] = applyTopOutput(active, o1_enabled, o1_required, o1_dir, o1_mode, o1_source, o1_valA, o1_valB, o1_score, outA, outB, outC, outD)
    topLongScore  += o1L
    topShortScore += o1S
    reqLongOk     := reqLongOk  and o1ReqL
    reqShortOk    := reqShortOk and o1ReqS

    // O2
    [o2L, o2S, o2ReqL, o2ReqS] = applyTopOutput(active, o2_enabled, o2_required, o2_dir, o2_mode, o2_source, o2_valA, o2_valB, o2_score, outA, outB, outC, outD)
    topLongScore  += o2L
    topShortScore += o2S
    reqLongOk     := reqLongOk  and o2ReqL
    reqShortOk    := reqShortOk and o2ReqS

    // O3
    [o3L, o3S, o3ReqL, o3ReqS] = applyTopOutput(active, o3_enabled, o3_required, o3_dir, o3_mode, o3_source, o3_valA, o3_valB, o3_score, outA, outB, outC, outD)
    topLongScore  += o3L
    topShortScore += o3S
    reqLongOk     := reqLongOk  and o3ReqL
    reqShortOk    := reqShortOk and o3ReqS

    // O4
    [o4L, o4S, o4ReqL, o4ReqS] = applyTopOutput(active, o4_enabled, o4_required, o4_dir, o4_mode, o4_source, o4_valA, o4_valB, o4_score, outA, outB, outC, outD)
    topLongScore  += o4L
    topShortScore += o4S
    reqLongOk     := reqLongOk  and o4ReqL
    reqShortOk    := reqShortOk and o4ReqS

    [topLongScore, topShortScore, reqLongOk, reqShortOk]

//──────────────────────────────────────────────────────────────────────────────
// Global Confluence – combine Top + Side and compute grades
//──────────────────────────────────────────────────────────────────────────────

// This function is meant to be the single entry point from the main script.
// The main script computes:
//   • Top module partial confluence via calcTopConfluence()
//   • Side/TF partial confluence (to be added later)
// and passes both into calcGlobalConfluence().
calcGlobalConfluence(float topLongScore, float topShortScore, bool topReqLongOk, bool topReqShortOk, float sideLongScore, float sideShortScore, bool sideReqLongOk, bool sideReqShortOk, int gradeC_long, int gradeB_long, int gradeA_long, int gradeC_short, int gradeB_short, int gradeA_short) =>
    float longScore  = topLongScore  + sideLongScore
    float shortScore = topShortScore + sideShortScore
    bool  longReqOk  = topReqLongOk  and sideReqLongOk
    bool  shortReqOk = topReqShortOk and sideReqShortOk

    string longGrade = "None"
    string shortGrade = "None"

    if not longReqOk
        longGrade := "Fail"
    else if longScore >= gradeA_long
        longGrade := "A"
    else if longScore >= gradeB_long
        longGrade := "B"
    else if longScore >= gradeC_long
        longGrade := "C"

    if not shortReqOk
        shortGrade := "Fail"
    else if shortScore >= gradeA_short
        shortGrade := "A"
    else if shortScore >= gradeB_short
        shortGrade := "B"
    else if shortScore >= gradeC_short
        shortGrade := "C"

    ConfluenceResult.new(longScore, shortScore, longReqOk, shortReqOk, longGrade, shortGrade)


// 9.1 Top Module 1 partial confluence


[topLongScore, topShortScore, topReqLongOk, topReqShortOk] =calcTopConfluence(top1_enabled, top1_library,top1_raw.outA, top1_raw.outB, top1_raw.outC, top1_raw.outD,top1_o1_enabled, top1_o1_required, top1_o1_dir, top1_o1_mode, top1_o1_source, top1_o1_valA, top1_o1_valB, top1_o1_score,top1_o2_enabled, top1_o2_required, top1_o2_dir, top1_o2_mode, top1_o2_source, top1_o2_valA, top1_o2_valB, top1_o2_score,top1_o3_enabled, top1_o3_required, top1_o3_dir, top1_o3_mode, top1_o3_source, top1_o3_valA, top1_o3_valB, top1_o3_score,top1_o4_enabled, top1_o4_required, top1_o4_dir, top1_o4_mode, top1_o4_source, top1_o4_valA, top1_o4_valB, top1_o4_score)

//──────────────────────────────────────────────────────────────────────────────
// 9.1.1 VWAP TOP TABLE CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
// VWAP contributes to top module scores based on D/W/M zone matches

int _vwap_longScore = 0
int _vwap_shortScore = 0
bool _vwap_longReqOk = true
bool _vwap_shortReqOk = true

if lib_vwap_enabled
    // Daily VWAP scoring
    if _kb_vwapZoneMatch(lib_vwap_D_zone, lib_vwap_D_long) and lib_vwap_D_score > 0
        _vwap_longScore += lib_vwap_D_score
    if _kb_vwapZoneMatch(lib_vwap_D_zone, lib_vwap_D_short) and lib_vwap_D_score > 0
        _vwap_shortScore += lib_vwap_D_score
    if lib_vwap_D_req and lib_vwap_D_long != "None" and not _kb_vwapZoneMatch(lib_vwap_D_zone, lib_vwap_D_long)
        _vwap_longReqOk := false
    if lib_vwap_D_req and lib_vwap_D_short != "None" and not _kb_vwapZoneMatch(lib_vwap_D_zone, lib_vwap_D_short)
        _vwap_shortReqOk := false

    // Weekly VWAP scoring
    if _kb_vwapZoneMatch(lib_vwap_W_zone, lib_vwap_W_long) and lib_vwap_W_score > 0
        _vwap_longScore += lib_vwap_W_score
    if _kb_vwapZoneMatch(lib_vwap_W_zone, lib_vwap_W_short) and lib_vwap_W_score > 0
        _vwap_shortScore += lib_vwap_W_score
    if lib_vwap_W_req and lib_vwap_W_long != "None" and not _kb_vwapZoneMatch(lib_vwap_W_zone, lib_vwap_W_long)
        _vwap_longReqOk := false
    if lib_vwap_W_req and lib_vwap_W_short != "None" and not _kb_vwapZoneMatch(lib_vwap_W_zone, lib_vwap_W_short)
        _vwap_shortReqOk := false

    // Monthly VWAP scoring
    if _kb_vwapZoneMatch(lib_vwap_M_zone, lib_vwap_M_long) and lib_vwap_M_score > 0
        _vwap_longScore += lib_vwap_M_score
    if _kb_vwapZoneMatch(lib_vwap_M_zone, lib_vwap_M_short) and lib_vwap_M_score > 0
        _vwap_shortScore += lib_vwap_M_score
    if lib_vwap_M_req and lib_vwap_M_long != "None" and not _kb_vwapZoneMatch(lib_vwap_M_zone, lib_vwap_M_long)
        _vwap_longReqOk := false
    if lib_vwap_M_req and lib_vwap_M_short != "None" and not _kb_vwapZoneMatch(lib_vwap_M_zone, lib_vwap_M_short)
        _vwap_shortReqOk := false

// Add VWAP scores to top module totals
topLongScore  += _vwap_longScore
topShortScore += _vwap_shortScore
topReqLongOk  := topReqLongOk and _vwap_longReqOk
topReqShortOk := topReqShortOk and _vwap_shortReqOk

// 9.2 Side/TF partial confluence

//──────────────────────────────────────────────────────────────────────────────
// SIDE TF CONFLUENCE SCORING
// NOTE: TFModuleOutput type is imported from the library (side1Lib/tfEMAStack).
// Each library exposes getTFConfluence() returning per-TF conditions + trigger.
//──────────────────────────────────────────────────────────────────────────────

float sideLongScore  = 0.0
float sideShortScore = 0.0
bool  sideReqLongOk  = true
bool  sideReqShortOk = true

// Helper: evaluate one TF row (score + required) for a given direction.
// Returns: [addedScore, updatedReqOk, tfMatched]
//  • tfScore   = TF TH Score (0 means "this TF is ignored")
//  • tfReq     = Required toggle
//  • tfInv     = Inv Label toggle (invert the condition)
//  • cond      = raw condition (TRUE/FALSE for this TF)
//  • reqOkIn   = current required-OK flag for this direction
_kb_evalSideTF(int tfScore, bool tfReq, bool tfInv, bool cond, bool reqOkIn) =>
    float add      = 0.0
    bool  reqOkOut = reqOkIn
    bool  matched  = false
    if tfScore > 0
        bool effective = tfInv ? not cond : cond
        matched := effective
        if effective
            add := tfScore
        else if tfReq
            reqOkOut := false
    [add, reqOkOut, matched]

//──────────────────────────────────────────────────────────────────────────────
// V2 LIBRARY-CENTRIC CONFLUENCE SCORING
// Each library contributes to confluence based on its own input settings.
//──────────────────────────────────────────────────────────────────────────────

//──────────────────────────────────────────────────────────────────────────────
// EMA STACK CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_ema_enabled and lib_ema_LEC_enable and lib_ema_LEC_func != "None"
    int _ema_LE_condIdx = _kb_mapCondSource(lib_ema_LEC_func)
    if _ema_LE_condIdx >= 0
        // Per-TF conditions from EMA Stack V2 output
        bool condLE_tf1 = _kb_getCondTF1(lib_ema_v2, _ema_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_ema_v2, _ema_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_ema_v2, _ema_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_ema_v2, _ema_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_ema_v2, _ema_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_ema_v2, _ema_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_ema_LE_tf1 : _i == 2 ? lib_ema_LE_tf2 : _i == 3 ? lib_ema_LE_tf3 : _i == 4 ? lib_ema_LE_tf4 : _i == 5 ? lib_ema_LE_tf5 : lib_ema_LE_tf6
            bool tfReq   = _i == 1 ? lib_ema_LE_tf1_req : _i == 2 ? lib_ema_LE_tf2_req : _i == 3 ? lib_ema_LE_tf3_req : _i == 4 ? lib_ema_LE_tf4_req : _i == 5 ? lib_ema_LE_tf5_req : lib_ema_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_ema_enabled and lib_ema_SEC_enable and lib_ema_SEC_func != "None"
    int _ema_SE_condIdx = _kb_mapCondSource(lib_ema_SEC_func)
    if _ema_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_ema_v2, _ema_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_ema_v2, _ema_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_ema_v2, _ema_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_ema_v2, _ema_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_ema_v2, _ema_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_ema_v2, _ema_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_ema_SE_tf1 : _i == 2 ? lib_ema_SE_tf2 : _i == 3 ? lib_ema_SE_tf3 : _i == 4 ? lib_ema_SE_tf4 : _i == 5 ? lib_ema_SE_tf5 : lib_ema_SE_tf6
            bool tfReq   = _i == 1 ? lib_ema_SE_tf1_req : _i == 2 ? lib_ema_SE_tf2_req : _i == 3 ? lib_ema_SE_tf3_req : _i == 4 ? lib_ema_SE_tf4_req : _i == 5 ? lib_ema_SE_tf5_req : lib_ema_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// RVOL CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_rvol_enabled and lib_rvol_LEC_enable and lib_rvol_LEC_func != "None"
    int _rvol_LE_condIdx = _kb_mapCondSource(lib_rvol_LEC_func)
    if _rvol_LE_condIdx >= 0
        bool condLE_tf1 = _kb_getCondTF1(lib_rvol_v2, _rvol_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_rvol_v2, _rvol_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_rvol_v2, _rvol_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_rvol_v2, _rvol_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_rvol_v2, _rvol_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_rvol_v2, _rvol_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_rvol_LE_tf1 : _i == 2 ? lib_rvol_LE_tf2 : _i == 3 ? lib_rvol_LE_tf3 : _i == 4 ? lib_rvol_LE_tf4 : _i == 5 ? lib_rvol_LE_tf5 : lib_rvol_LE_tf6
            bool tfReq   = _i == 1 ? lib_rvol_LE_tf1_req : _i == 2 ? lib_rvol_LE_tf2_req : _i == 3 ? lib_rvol_LE_tf3_req : _i == 4 ? lib_rvol_LE_tf4_req : _i == 5 ? lib_rvol_LE_tf5_req : lib_rvol_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_rvol_enabled and lib_rvol_SEC_enable and lib_rvol_SEC_func != "None"
    int _rvol_SE_condIdx = _kb_mapCondSource(lib_rvol_SEC_func)
    if _rvol_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_rvol_v2, _rvol_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_rvol_v2, _rvol_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_rvol_v2, _rvol_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_rvol_v2, _rvol_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_rvol_v2, _rvol_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_rvol_v2, _rvol_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_rvol_SE_tf1 : _i == 2 ? lib_rvol_SE_tf2 : _i == 3 ? lib_rvol_SE_tf3 : _i == 4 ? lib_rvol_SE_tf4 : _i == 5 ? lib_rvol_SE_tf5 : lib_rvol_SE_tf6
            bool tfReq   = _i == 1 ? lib_rvol_SE_tf1_req : _i == 2 ? lib_rvol_SE_tf2_req : _i == 3 ? lib_rvol_SE_tf3_req : _i == 4 ? lib_rvol_SE_tf4_req : _i == 5 ? lib_rvol_SE_tf5_req : lib_rvol_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// UT BOT CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_utbot_enabled and lib_utbot_LEC_enable and lib_utbot_LEC_func != "None"
    int _utbot_LE_condIdx = _kb_mapCondSource(lib_utbot_LEC_func)
    if _utbot_LE_condIdx >= 0
        bool condLE_tf1 = _kb_getCondTF1(lib_utbot_v2, _utbot_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_utbot_v2, _utbot_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_utbot_v2, _utbot_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_utbot_v2, _utbot_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_utbot_v2, _utbot_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_utbot_v2, _utbot_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_utbot_LE_tf1 : _i == 2 ? lib_utbot_LE_tf2 : _i == 3 ? lib_utbot_LE_tf3 : _i == 4 ? lib_utbot_LE_tf4 : _i == 5 ? lib_utbot_LE_tf5 : lib_utbot_LE_tf6
            bool tfReq   = _i == 1 ? lib_utbot_LE_tf1_req : _i == 2 ? lib_utbot_LE_tf2_req : _i == 3 ? lib_utbot_LE_tf3_req : _i == 4 ? lib_utbot_LE_tf4_req : _i == 5 ? lib_utbot_LE_tf5_req : lib_utbot_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_utbot_enabled and lib_utbot_SEC_enable and lib_utbot_SEC_func != "None"
    int _utbot_SE_condIdx = _kb_mapCondSource(lib_utbot_SEC_func)
    if _utbot_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_utbot_v2, _utbot_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_utbot_v2, _utbot_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_utbot_v2, _utbot_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_utbot_v2, _utbot_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_utbot_v2, _utbot_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_utbot_v2, _utbot_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_utbot_SE_tf1 : _i == 2 ? lib_utbot_SE_tf2 : _i == 3 ? lib_utbot_SE_tf3 : _i == 4 ? lib_utbot_SE_tf4 : _i == 5 ? lib_utbot_SE_tf5 : lib_utbot_SE_tf6
            bool tfReq   = _i == 1 ? lib_utbot_SE_tf1_req : _i == 2 ? lib_utbot_SE_tf2_req : _i == 3 ? lib_utbot_SE_tf3_req : _i == 4 ? lib_utbot_SE_tf4_req : _i == 5 ? lib_utbot_SE_tf5_req : lib_utbot_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// SWING 123 CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_swing_enabled and lib_swing_LEC_enable and lib_swing_LEC_func != "None"
    int _swing_LE_condIdx = _kb_mapCondSource(lib_swing_LEC_func)
    if _swing_LE_condIdx >= 0
        bool condLE_tf1 = _kb_getCondTF1(lib_swing_v2, _swing_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_swing_v2, _swing_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_swing_v2, _swing_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_swing_v2, _swing_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_swing_v2, _swing_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_swing_v2, _swing_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_swing_LE_tf1 : _i == 2 ? lib_swing_LE_tf2 : _i == 3 ? lib_swing_LE_tf3 : _i == 4 ? lib_swing_LE_tf4 : _i == 5 ? lib_swing_LE_tf5 : lib_swing_LE_tf6
            bool tfReq   = _i == 1 ? lib_swing_LE_tf1_req : _i == 2 ? lib_swing_LE_tf2_req : _i == 3 ? lib_swing_LE_tf3_req : _i == 4 ? lib_swing_LE_tf4_req : _i == 5 ? lib_swing_LE_tf5_req : lib_swing_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_swing_enabled and lib_swing_SEC_enable and lib_swing_SEC_func != "None"
    int _swing_SE_condIdx = _kb_mapCondSource(lib_swing_SEC_func)
    if _swing_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_swing_v2, _swing_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_swing_v2, _swing_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_swing_v2, _swing_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_swing_v2, _swing_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_swing_v2, _swing_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_swing_v2, _swing_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_swing_SE_tf1 : _i == 2 ? lib_swing_SE_tf2 : _i == 3 ? lib_swing_SE_tf3 : _i == 4 ? lib_swing_SE_tf4 : _i == 5 ? lib_swing_SE_tf5 : lib_swing_SE_tf6
            bool tfReq   = _i == 1 ? lib_swing_SE_tf1_req : _i == 2 ? lib_swing_SE_tf2_req : _i == 3 ? lib_swing_SE_tf3_req : _i == 4 ? lib_swing_SE_tf4_req : _i == 5 ? lib_swing_SE_tf5_req : lib_swing_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// MACD LINE CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_macdl_enabled and lib_macdl_LEC_enable and lib_macdl_LEC_func != "None"
    int _macdl_LE_condIdx = _kb_mapCondSource(lib_macdl_LEC_func)
    if _macdl_LE_condIdx >= 0
        bool condLE_tf1 = _kb_getCondTF1(lib_macdl_v2, _macdl_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_macdl_v2, _macdl_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_macdl_v2, _macdl_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_macdl_v2, _macdl_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_macdl_v2, _macdl_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_macdl_v2, _macdl_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_macdl_LE_tf1 : _i == 2 ? lib_macdl_LE_tf2 : _i == 3 ? lib_macdl_LE_tf3 : _i == 4 ? lib_macdl_LE_tf4 : _i == 5 ? lib_macdl_LE_tf5 : lib_macdl_LE_tf6
            bool tfReq   = _i == 1 ? lib_macdl_LE_tf1_req : _i == 2 ? lib_macdl_LE_tf2_req : _i == 3 ? lib_macdl_LE_tf3_req : _i == 4 ? lib_macdl_LE_tf4_req : _i == 5 ? lib_macdl_LE_tf5_req : lib_macdl_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_macdl_enabled and lib_macdl_SEC_enable and lib_macdl_SEC_func != "None"
    int _macdl_SE_condIdx = _kb_mapCondSource(lib_macdl_SEC_func)
    if _macdl_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_macdl_v2, _macdl_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_macdl_v2, _macdl_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_macdl_v2, _macdl_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_macdl_v2, _macdl_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_macdl_v2, _macdl_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_macdl_v2, _macdl_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_macdl_SE_tf1 : _i == 2 ? lib_macdl_SE_tf2 : _i == 3 ? lib_macdl_SE_tf3 : _i == 4 ? lib_macdl_SE_tf4 : _i == 5 ? lib_macdl_SE_tf5 : lib_macdl_SE_tf6
            bool tfReq   = _i == 1 ? lib_macdl_SE_tf1_req : _i == 2 ? lib_macdl_SE_tf2_req : _i == 3 ? lib_macdl_SE_tf3_req : _i == 4 ? lib_macdl_SE_tf4_req : _i == 5 ? lib_macdl_SE_tf5_req : lib_macdl_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// MACD HISTOGRAM CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_macdh_enabled and lib_macdh_LEC_enable and lib_macdh_LEC_func != "None"
    int _macdh_LE_condIdx = _kb_mapCondSource(lib_macdh_LEC_func)
    if _macdh_LE_condIdx >= 0
        bool condLE_tf1 = _kb_getCondTF1(lib_macdh_v2, _macdh_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_macdh_v2, _macdh_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_macdh_v2, _macdh_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_macdh_v2, _macdh_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_macdh_v2, _macdh_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_macdh_v2, _macdh_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_macdh_LE_tf1 : _i == 2 ? lib_macdh_LE_tf2 : _i == 3 ? lib_macdh_LE_tf3 : _i == 4 ? lib_macdh_LE_tf4 : _i == 5 ? lib_macdh_LE_tf5 : lib_macdh_LE_tf6
            bool tfReq   = _i == 1 ? lib_macdh_LE_tf1_req : _i == 2 ? lib_macdh_LE_tf2_req : _i == 3 ? lib_macdh_LE_tf3_req : _i == 4 ? lib_macdh_LE_tf4_req : _i == 5 ? lib_macdh_LE_tf5_req : lib_macdh_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_macdh_enabled and lib_macdh_SEC_enable and lib_macdh_SEC_func != "None"
    int _macdh_SE_condIdx = _kb_mapCondSource(lib_macdh_SEC_func)
    if _macdh_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_macdh_v2, _macdh_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_macdh_v2, _macdh_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_macdh_v2, _macdh_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_macdh_v2, _macdh_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_macdh_v2, _macdh_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_macdh_v2, _macdh_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_macdh_SE_tf1 : _i == 2 ? lib_macdh_SE_tf2 : _i == 3 ? lib_macdh_SE_tf3 : _i == 4 ? lib_macdh_SE_tf4 : _i == 5 ? lib_macdh_SE_tf5 : lib_macdh_SE_tf6
            bool tfReq   = _i == 1 ? lib_macdh_SE_tf1_req : _i == 2 ? lib_macdh_SE_tf2_req : _i == 3 ? lib_macdh_SE_tf3_req : _i == 4 ? lib_macdh_SE_tf4_req : _i == 5 ? lib_macdh_SE_tf5_req : lib_macdh_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// SIMPLE MACD CONFLUENCE
//──────────────────────────────────────────────────────────────────────────────
if lib_macds_enabled and lib_macds_LEC_enable and lib_macds_LEC_func != "None"
    int _macds_LE_condIdx = _kb_mapCondSource(lib_macds_LEC_func)
    if _macds_LE_condIdx >= 0
        bool condLE_tf1 = _kb_getCondTF1(lib_macds_v2, _macds_LE_condIdx)
        bool condLE_tf2 = _kb_getCondTF2(lib_macds_v2, _macds_LE_condIdx)
        bool condLE_tf3 = _kb_getCondTF3(lib_macds_v2, _macds_LE_condIdx)
        bool condLE_tf4 = _kb_getCondTF4(lib_macds_v2, _macds_LE_condIdx)
        bool condLE_tf5 = _kb_getCondTF5(lib_macds_v2, _macds_LE_condIdx)
        bool condLE_tf6 = _kb_getCondTF6(lib_macds_v2, _macds_LE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_macds_LE_tf1 : _i == 2 ? lib_macds_LE_tf2 : _i == 3 ? lib_macds_LE_tf3 : _i == 4 ? lib_macds_LE_tf4 : _i == 5 ? lib_macds_LE_tf5 : lib_macds_LE_tf6
            bool tfReq   = _i == 1 ? lib_macds_LE_tf1_req : _i == 2 ? lib_macds_LE_tf2_req : _i == 3 ? lib_macds_LE_tf3_req : _i == 4 ? lib_macds_LE_tf4_req : _i == 5 ? lib_macds_LE_tf5_req : lib_macds_LE_tf6_req
            bool tfCond  = _i == 1 ? condLE_tf1 : _i == 2 ? condLE_tf2 : _i == 3 ? condLE_tf3 : _i == 4 ? condLE_tf4 : _i == 5 ? condLE_tf5 : condLE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqLongOk)
            sideReqLongOk := reqOut
            sideLongScore += addTF

if lib_macds_enabled and lib_macds_SEC_enable and lib_macds_SEC_func != "None"
    int _macds_SE_condIdx = _kb_mapCondSource(lib_macds_SEC_func)
    if _macds_SE_condIdx >= 0
        bool condSE_tf1 = _kb_getCondTF1(lib_macds_v2, _macds_SE_condIdx)
        bool condSE_tf2 = _kb_getCondTF2(lib_macds_v2, _macds_SE_condIdx)
        bool condSE_tf3 = _kb_getCondTF3(lib_macds_v2, _macds_SE_condIdx)
        bool condSE_tf4 = _kb_getCondTF4(lib_macds_v2, _macds_SE_condIdx)
        bool condSE_tf5 = _kb_getCondTF5(lib_macds_v2, _macds_SE_condIdx)
        bool condSE_tf6 = _kb_getCondTF6(lib_macds_v2, _macds_SE_condIdx)

        for _i = 1 to 6
            int  tfScore = _i == 1 ? lib_macds_SE_tf1 : _i == 2 ? lib_macds_SE_tf2 : _i == 3 ? lib_macds_SE_tf3 : _i == 4 ? lib_macds_SE_tf4 : _i == 5 ? lib_macds_SE_tf5 : lib_macds_SE_tf6
            bool tfReq   = _i == 1 ? lib_macds_SE_tf1_req : _i == 2 ? lib_macds_SE_tf2_req : _i == 3 ? lib_macds_SE_tf3_req : _i == 4 ? lib_macds_SE_tf4_req : _i == 5 ? lib_macds_SE_tf5_req : lib_macds_SE_tf6_req
            bool tfCond  = _i == 1 ? condSE_tf1 : _i == 2 ? condSE_tf2 : _i == 3 ? condSE_tf3 : _i == 4 ? condSE_tf4 : _i == 5 ? condSE_tf5 : condSE_tf6
            [addTF, reqOut, matchOut] = _kb_evalSideTF(tfScore, tfReq, false, tfCond, sideReqShortOk)
            sideReqShortOk := reqOut
            sideShortScore += addTF

//──────────────────────────────────────────────────────────────────────────────
// EXIT CONFLUENCE SCORING
// Exit confluence not yet implemented for v2 libraries - placeholder
//──────────────────────────────────────────────────────────────────────────────

float sideLongExitScore  = 0.0
float sideShortExitScore = 0.0
bool  sideReqLongExitOk  = true
bool  sideReqShortExitOk = true

// 9.3 Global confluence
ConfluenceResult _kb_conf =calcGlobalConfluence(topLongScore, topShortScore,topReqLongOk, topReqShortOk,sideLongScore, sideShortScore,sideReqLongOk, sideReqShortOk,gradeC_long, gradeB_long, gradeA_long,gradeC_short, gradeB_short, gradeA_short)


// 9.4 Expose for other modules (Position Engine + Top Table)
// Entry confluence
float  _kb_longScore   = _kb_conf.longScore
float  _kb_shortScore  = _kb_conf.shortScore
bool   _kb_longReqOk   = _kb_conf.longReqOk
bool   _kb_shortReqOk  = _kb_conf.shortReqOk
string _kb_longGrade   = _kb_conf.longGrade
string _kb_shortGrade  = _kb_conf.shortGrade

// 9.5 Exit confluence exposure
float  _kb_longExitScore   = sideLongExitScore
float  _kb_shortExitScore  = sideShortExitScore
bool   _kb_longExitReqOk   = sideReqLongExitOk
bool   _kb_shortExitReqOk  = sideReqShortExitOk


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 10. POSITION ENGINE
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// KevBot Toolkit v1.0 — Position Engine Module
// Drop this block into your main KevBot script **after** the Confluence Engine.
// Assumes the following are already defined earlier in the script:
//   • bool  rawLongEntry,  rawLongExit,  rawShortEntry, rawShortExit
//   • string sizer_entry, sizer_exit
//   • bool  sizerAllowMulti
//   • int   sizerMaxEntries
//   • (Optional for later) confluence grades from the Confluence Engine.
// For now, grade-based modes will be wired but will only work once you
// assign `_kb_longGrade` and `_kb_shortGrade` from your ConfluenceResult.



// Placeholder confluence grades (to be wired to ConfluenceResult later).
// Example once wired:
//   _kb_longGrade  := globalConf.longGrade
//   _kb_shortGrade := globalConf.shortGrade

// Helper: check if a grade meets a minimum requirement.
// "C" => C/B/A pass, "B" => B/A pass, "A" => A only.
_kb_gradeAtLeast(string grade, string minGrade) => (minGrade == "C" and (grade == "C" or grade == "B" or grade == "A")) or (minGrade == "B" and (grade == "B" or grade == "A")) or (minGrade == "A" and grade == "A")

//──────────────────────────────────────────────────────────────────────────────
// 10.1 Entry Method Resolution
//──────────────────────────────────────────────────────────────────────────────

// Resolve whether entries are allowed for long/short based on Position Entry
// Method and (eventually) confluence grades.

bool _kb_longEntryOK  = false
bool _kb_shortEntryOK = false

// Long side
if sizer_entry == "Any Entry Trigger" or sizer_entry == "Library Custom"
    // Pure raw trigger; ignore grades and requireds.
    _kb_longEntryOK := rawLongEntry
else if sizer_entry == "Entry Trigger + Grade C"
    _kb_longEntryOK := rawLongEntry and _kb_gradeAtLeast(_kb_longGrade, "C")
else if sizer_entry == "Entry Trigger + Grade B"
    _kb_longEntryOK := rawLongEntry and _kb_gradeAtLeast(_kb_longGrade, "B")
else if sizer_entry == "Entry Trigger + Grade A"
    _kb_longEntryOK := rawLongEntry and _kb_gradeAtLeast(_kb_longGrade, "A")

// Short side
if sizer_entry == "Any Entry Trigger" or sizer_entry == "Library Custom"
    _kb_shortEntryOK := rawShortEntry
else if sizer_entry == "Entry Trigger + Grade C"
    _kb_shortEntryOK := rawShortEntry and _kb_gradeAtLeast(_kb_shortGrade, "C")
else if sizer_entry == "Entry Trigger + Grade B"
    _kb_shortEntryOK := rawShortEntry and _kb_gradeAtLeast(_kb_shortGrade, "B")
else if sizer_entry == "Entry Trigger + Grade A"
    _kb_shortEntryOK := rawShortEntry and _kb_gradeAtLeast(_kb_shortGrade, "A")

//──────────────────────────────────────────────────────────────────────────────
// 10.2 Exit Method Resolution
//──────────────────────────────────────────────────────────────────────────────

// Resolve whether exits are allowed for long/short based on Position Exit
// Method, confluence grades, AND exit TF requirements.

bool _kb_longExitOK  = false
bool _kb_shortExitOK = false

// Long exits
// Exit confluence requirements must pass if any exit TF scores are configured
if sizer_exit == "First Exit Trigger" or sizer_exit == "Library Custom"
    // Raw exits only, but still check exit TF requirements if configured
    _kb_longExitOK := rawLongExit and _kb_longExitReqOk
else if sizer_exit == "Exit Trigger + Grade C"
    _kb_longExitOK := rawLongExit and _kb_gradeAtLeast(_kb_longGrade, "C") and _kb_longExitReqOk
else if sizer_exit == "Exit Trigger + Grade B"
    _kb_longExitOK := rawLongExit and _kb_gradeAtLeast(_kb_longGrade, "B") and _kb_longExitReqOk
else if sizer_exit == "Exit Trigger + Grade A"
    _kb_longExitOK := rawLongExit and _kb_gradeAtLeast(_kb_longGrade, "A") and _kb_longExitReqOk

// Short exits
if sizer_exit == "First Exit Trigger" or sizer_exit == "Library Custom"
    _kb_shortExitOK := rawShortExit and _kb_shortExitReqOk
else if sizer_exit == "Exit Trigger + Grade C"
    _kb_shortExitOK := rawShortExit and _kb_gradeAtLeast(_kb_shortGrade, "C") and _kb_shortExitReqOk
else if sizer_exit == "Exit Trigger + Grade B"
    _kb_shortExitOK := rawShortExit and _kb_gradeAtLeast(_kb_shortGrade, "B") and _kb_shortExitReqOk
else if sizer_exit == "Exit Trigger + Grade A"
    _kb_shortExitOK := rawShortExit and _kb_gradeAtLeast(_kb_shortGrade, "A") and _kb_shortExitReqOk

//──────────────────────────────────────────────────────────────────────────────
// 10.3 Position State Machine
//──────────────────────────────────────────────────────────────────────────────

// posDir:  0 = flat, 1 = long, -1 = short
var int _kb_posDir     = 0
var int _kb_posEntries = 0

// Output signals from the Position Engine.
bool positionLongEntry  = false
bool positionShortEntry = false
bool positionLongExit   = false
bool positionShortExit  = false

// Helper: can we add another long entry (respecting stacking rules)?
bool _kb_canAddLong = false
if not sizerAllowMulti
    // Single-entry mode: only from flat to long.
    _kb_canAddLong := _kb_posDir == 0
else
    if _kb_posDir == 0
        _kb_canAddLong := true
    else if _kb_posDir == 1
        _kb_canAddLong := _kb_posEntries < sizerMaxEntries
    else if _kb_posDir == -1
        _kb_canAddLong := false

// Helper: can we add another short entry (respecting stacking rules)?
bool _kb_canAddShort = false
if not sizerAllowMulti
    _kb_canAddShort := _kb_posDir == 0
else
    if _kb_posDir == 0
        _kb_canAddShort := true
    else if _kb_posDir == -1
        _kb_canAddShort := _kb_posEntries < sizerMaxEntries
    else if _kb_posDir == 1
        _kb_canAddShort := false

// Long entry logic
if _kb_longEntryOK and _kb_canAddLong
    positionLongEntry := true
    if _kb_posDir != 1
        _kb_posDir := 1
        _kb_posEntries := 1
    else
        _kb_posEntries += 1

// Short entry logic
if _kb_shortEntryOK and _kb_canAddShort
    positionShortEntry := true
    if _kb_posDir != -1
        _kb_posDir := -1
        _kb_posEntries := 1
    else
        _kb_posEntries += 1

// Long exit logic — only valid if currently long.
if _kb_posDir == 1 and _kb_longExitOK
    positionLongExit := true
    _kb_posDir := 0
    _kb_posEntries := 0

// Short exit logic — only valid if currently short.
if _kb_posDir == -1 and _kb_shortExitOK
    positionShortExit := true
    _kb_posDir := 0
    _kb_posEntries := 0

// You can now feed positionLongEntry/positionShortEntry/positionLongExit/
// positionShortExit into the Backtest Engine, label system, and alert manager
// in later phases of the KevBot Toolkit.

//──────────────────────────────────────────────────────────────────────────────
// 11. BACKTEST ENGINE
//──────────────────────────────────────────────────────────────────────────────

//──────────────────────────────────────────────────────────────────────────────
// KevBot Toolkit – BACKTEST ENGINE MODULE (Block 11)
// Minimal trade tracking, single-entry or multi-entry compatible
//──────────────────────────────────────────────────────────────────────────────

// This module is designed to be pasted directly after the Position Engine.
// It expects the following variables to already exist in the main script:
//   • positionLongEntry, positionShortEntry (bool)
//   • positionLongExit,  positionShortExit  (bool)
//   • riskMode, acctSize, defShares, defRisk, defRiskPct
//   • sl_method, tp_method, sl_show, tp_show (not fully wired yet)
//   • current candle OHLC
//   • settings for multi-entry stacking
//   • sizerAllowMulti, sizerMaxEntries
//
// OUTPUT:
//   • bt_positionActive   (bool)
//   • bt_positionSide     ("LONG" / "SHORT" / "NONE")
//   • bt_entryPrice
//   • bt_exitPrice
//   • bt_qty
//   • bt_realizedPNL
//   • bt_winCount, bt_lossCount, bt_totalTrades
//   • bt_lastTradePNL
//──────────────────────────────────────────────────────────────────────────────

//──────────────────────────────────────────────────────────────────────────────
// BACKTEST ENGINE INTERNAL STATE
//──────────────────────────────────────────────────────────────────────────────

var bool  bt_positionActive = false
var string bt_positionSide  = "NONE"     // "LONG" or "SHORT"
var float bt_entryPrice     = na
var float bt_exitPrice      = na
var float bt_qty            = 0.0
var float bt_realizedPNL    = 0.0

var float bt_lastTradePNL = 0.0
var int   bt_totalTrades  = 0
var int   bt_winCount     = 0
var int   bt_lossCount    = 0

// track stacked entries
var int   bt_stackCount = 0

// Stats for PF + drawdown
var float bt_grossWin    = 0.0
var float bt_grossLoss   = 0.0    // will be negative
var float bt_maxDrawdown = 0.0    // as fraction (0.075 = 7.5%)
var float bt_peakEquity  = 0.0    // best realized PNL so far

//──────────────────────────────────────────────────────────────────────────────
// Helper: compute position size based on Risk Mode + Grade Multipliers
// dir: 1=long, -1=short
_kb_calcQty(float price, int dir) =>
    // Base quantity from risk mode
    float baseQty = riskMode == "Share Qty" ? defShares : riskMode == "Fixed $ Risk" ? (defRisk / (price * 0.01)) : riskMode == "Percentage Risk" ? ((acctSize * defRiskPct * 0.01) / (price * 0.01)) : defShares

    // Apply grade-based risk multiplier
    float mult = 1.0
    if dir == 1
        // Long multipliers
        mult := _kb_longGrade == "A" ? mult_AL : _kb_longGrade == "B" ? mult_BL : _kb_longGrade == "C" ? mult_CL : 1.0
    else if dir == -1
        // Short multipliers
        mult := _kb_shortGrade == "A" ? mult_AS : _kb_shortGrade == "B" ? mult_BS : _kb_shortGrade == "C" ? mult_CS : 1.0

    baseQty * mult

//──────────────────────────────────────────────────────────────────────────────
// 11.0 BACKTEST FILTERS
//──────────────────────────────────────────────────────────────────────────────

// Window filter: check if current bar is within the backtest window
bool _bt_windowOk = true
if backWindow == "Fixed Bars"
    _bt_windowOk := bar_index >= (last_bar_index - backBars)
else if backWindow == "Date Range"
    _bt_windowOk := time >= backStartDate and (not backUseEnd or time <= backEndDate)

// Session filter: check if current bar is within the allowed time of day
bool _bt_sessionOk = not na(time(timeframe.period, backSession))

// Day of week filter: check if current day is allowed
// dayofweek: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
int _bt_dow = dayofweek
bool _bt_dowOk = (_bt_dow == 2 and backUseDOW_M) or (_bt_dow == 3 and backUseDOW_T) or (_bt_dow == 4 and backUseDOW_W) or (_bt_dow == 5 and backUseDOW_Th) or (_bt_dow == 6 and backUseDOW_F) or (_bt_dow == 7 and backUseDOW_Sa) or (_bt_dow == 1 and backUseDOW_Su)

// Combined filter: all conditions must pass for entries
bool _kb_btFilterPass = _bt_windowOk and _bt_sessionOk and _bt_dowOk

//──────────────────────────────────────────────────────────────────────────────
// ENTRY LOGIC (gated by backtest filters)
//──────────────────────────────────────────────────────────────────────────────

bool _longEntry  = positionLongEntry and _kb_btFilterPass
bool _shortEntry = positionShortEntry and _kb_btFilterPass

float _entryFill = close   // assume filled at close for now

// LONG ENTRY
if _longEntry and not bt_positionActive
    bt_positionActive := true
    bt_positionSide   := "LONG"
    bt_entryPrice     := _entryFill
    bt_qty            := _kb_calcQty(_entryFill, 1)
    bt_stackCount     := 1

// stacking additional entries while already in a long (also filtered)
if _longEntry and bt_positionActive and bt_positionSide == "LONG" and sizerAllowMulti and bt_stackCount < sizerMaxEntries
    bt_qty        += _kb_calcQty(_entryFill, 1)
    bt_entryPrice := (bt_entryPrice * bt_stackCount + _entryFill) / (bt_stackCount + 1)
    bt_stackCount += 1

// SHORT ENTRY
if _shortEntry and not bt_positionActive
    bt_positionActive := true
    bt_positionSide   := "SHORT"
    bt_entryPrice     := _entryFill
    bt_qty            := _kb_calcQty(_entryFill, -1)
    bt_stackCount     := 1

// stacking additional entries while already in a short (also filtered)
if _shortEntry and bt_positionActive and bt_positionSide == "SHORT" and sizerAllowMulti and bt_stackCount < sizerMaxEntries
    bt_qty        += _kb_calcQty(_entryFill, -1)
    bt_entryPrice := (bt_entryPrice * bt_stackCount + _entryFill) / (bt_stackCount + 1)
    bt_stackCount += 1

//──────────────────────────────────────────────────────────────────────────────
// EXIT LOGIC
//──────────────────────────────────────────────────────────────────────────────

bool _longExit  = positionLongExit
bool _shortExit = positionShortExit

float _exitFill = close

if bt_positionActive
    // LONG EXIT
    if bt_positionSide == "LONG" and _longExit
        bt_exitPrice     := _exitFill
        bt_lastTradePNL  := (bt_exitPrice - bt_entryPrice) * bt_qty
        bt_realizedPNL  += bt_lastTradePNL
        bt_totalTrades  += 1
        bt_winCount     += bt_lastTradePNL > 0 ? 1 : 0
        bt_lossCount    += bt_lastTradePNL < 0 ? 1 : 0

        // PF components
        if bt_lastTradePNL > 0
            bt_grossWin += bt_lastTradePNL
        else if bt_lastTradePNL < 0
            bt_grossLoss += bt_lastTradePNL

        // Equity + max drawdown (based on realized PNL only)
        float _eq = bt_realizedPNL
        if _eq > bt_peakEquity
            bt_peakEquity := _eq
        float _dd = bt_peakEquity != 0.0 ? (bt_peakEquity - _eq) / math.abs(bt_peakEquity) : 0.0
        if _dd > bt_maxDrawdown
            bt_maxDrawdown := _dd


        bt_positionActive := false
        bt_positionSide   := "NONE"
        bt_qty            := 0
        bt_stackCount     := 0

    // SHORT EXIT
    if bt_positionSide == "SHORT" and _shortExit
        bt_exitPrice     := _exitFill
        bt_lastTradePNL  := (bt_entryPrice - bt_exitPrice) * bt_qty
        bt_realizedPNL  += bt_lastTradePNL
        bt_totalTrades  += 1
        bt_winCount     += bt_lastTradePNL > 0 ? 1 : 0
        bt_lossCount    += bt_lastTradePNL < 0 ? 1 : 0

        if bt_lastTradePNL > 0
            bt_grossWin += bt_lastTradePNL
        else if bt_lastTradePNL < 0
            bt_grossLoss += bt_lastTradePNL

        float _eq = bt_realizedPNL
        if _eq > bt_peakEquity
            bt_peakEquity := _eq
        float _dd = bt_peakEquity != 0.0 ? (bt_peakEquity - _eq) / math.abs(bt_peakEquity) : 0.0
        if _dd > bt_maxDrawdown
            bt_maxDrawdown := _dd


        bt_positionActive := false
        bt_positionSide   := "NONE"
        bt_qty            := 0
        bt_stackCount     := 0

//──────────────────────────────────────────────────────────────────────────────
// 11.1 Optional Debug Labels
//──────────────────────────────────────────────────────────────────────────────
// Uncomment if you want visual confirmation for entries/exits
// label.new(bar_index, high,  text="ENTRY LONG",  color=color.green)  if _longEntry
// label.new(bar_index, low,   text="EXIT LONG",   color=color.red)    if _longExit
// label.new(bar_index, high,  text="ENTRY SHORT", color=color.orange) if _shortEntry
// label.new(bar_index, low,   text="EXIT SHORT",  color=color.blue)   if _shortExit

//──────────────────────────────────────────────────────────────────────────────
// END BACKTEST ENGINE
//──────────────────────────────────────────────────────────────────────────────

//──────────────────────────────────────────────────────────────────────────────
// KevBot Toolkit – TOP MODULE TABLE (Dynamic Multi‑Module Renderer)
//──────────────────────────────────────────────────────────────────────────────
// Layout rules:
// • Each module = 5 rows x 2 columns
// • Modules are placed left→right in this order:
//      1. Long Confluence Module
//      2. Short Confluence Module
//      3. Position Sizing Module
//      4. Backtest KPI Module
//      5. Top Module 1 (external library)
// • Disabled modules do NOT appear and do NOT take space.
// • All rendering happens only on barstate.islast to minimize compute cost.
//──────────────────────────────────────────────────────────────────────────────

//──────────────────────────────────────────────────────────────────────────────
// 12.0 TOP TABLE SETTINGS
//──────────────────────────────────────────────────────────────────────────────

string GRP_TOP_TABLE = "12. Top Table (Module Grid)"

string topTable_position = input.string(
     "Top Center",
     "Top Table Position",
     options = ["Top Left", "Top Center", "Top Right"],
     group   = GRP_TOP_TABLE,
     tooltip = "Choose where to render the Top (module) table."
)

// Resolve table position
f_topTable_pos(string posLabel) =>
     posLabel == "Top Left"   ? position.top_left :
     posLabel == "Top Center" ? position.top_center : position.top_right

//──────────────────────────────────────────────────────────────────────────────
// 12.1 TABLE INITIALIZATION
//──────────────────────────────────────────────────────────────────────────────

var table kbTopTable = na
if enableTopTable and na(kbTopTable)
    kbTopTable := table.new(f_topTable_pos(topTable_position), 10, 20, frame_width = 1, bgcolor = color.new(color.gray, 85))

//──────────────────────────────────────────────────────────────────────────────
// 12.2 COLOR + TEXT SETTINGS (Theme-Aware)
//──────────────────────────────────────────────────────────────────────────────

// Dark theme colors
color _kb_headBg      = useDarkTheme ? color.new(color.blue, 40)   : color.new(color.blue, 70)   // Calculation modules
color _kb_confHeadBg  = useDarkTheme ? color.new(color.purple, 40) : color.new(color.purple, 70) // Confluence interpreter modules
color _kb_labBg       = useDarkTheme ? color.new(color.gray, 75)   : color.new(color.gray, 90)
color _kb_valBg   = useDarkTheme ? color.new(color.gray, 55)  : color.new(color.gray, 85)
color _kb_headTxt = useDarkTheme ? color.white : color.new(color.black, 0)
color _kb_labTxt  = useDarkTheme ? color.white : color.new(color.black, 20)
color _kb_valTxt  = useDarkTheme ? color.white : color.new(color.black, 0)

// VWAP zone cell color helper
// Returns: Green (Long match), Red (Short match), Blue (Both), Yellow (monitored), Gray (off)
f_vwapCell_color(string zone, string longCond, string shortCond, int score) =>
    bool longMatch = _kb_vwapZoneMatch(zone, longCond) and score > 0
    bool shortMatch = _kb_vwapZoneMatch(zone, shortCond) and score > 0
    bool monitored = (longCond != "None" or shortCond != "None") and score > 0

    color bg = _kb_valBg  // Default gray
    if monitored
        if longMatch and shortMatch
            bg := color.new(color.blue, 60)
        else if longMatch
            bg := color.new(color.green, 60)
        else if shortMatch
            bg := color.new(color.red, 60)
        else
            bg := color.new(color.yellow, 70)
    bg

//──────────────────────────────────────────────────────────────────────────────
// 12.3 MODULE ENABLE FLAGS
//──────────────────────────────────────────────────────────────────────────────

bool useLongCSM  = showCSM_long
bool useShortCSM = showCSM_short
bool useSizer    = showSizer
bool useBacktest = showBack
bool useTop1     = top1_enabled
bool useTopVWAP  = lib_vwap_enabled

// Count active modules
int activeCount = 0
activeCount += useLongCSM  ? 1 : 0
activeCount += useShortCSM ? 1 : 0
activeCount += useSizer    ? 1 : 0
activeCount += useBacktest ? 1 : 0
activeCount += useTop1     ? 1 : 0
activeCount += useTopVWAP  ? 1 : 0

//──────────────────────────────────────────────────────────────────────────────
// 12.4 COLUMN ASSIGNMENT
//──────────────────────────────────────────────────────────────────────────────
// Modules shift left automatically. For example, if only Long + Sizer are on,
// Long gets col=0, Sizer gets col=1, and others are skipped.
//──────────────────────────────────────────────────────────────────────────────

int colLong    = na
int colShort   = na
int colSizer   = na
int colBack    = na
int colTop1    = na
int colTopVWAP = na

int cursor = 0
if useLongCSM
    colLong := cursor
    cursor += 1
if useShortCSM
    colShort := cursor
    cursor += 1
if useSizer
    colSizer := cursor
    cursor += 1
if useBacktest
    colBack := cursor
    cursor += 1
if useTop1
    colTop1 := cursor
    cursor += 1
if useTopVWAP
    colTopVWAP := cursor
    cursor += 1

// Each module uses 2 columns → multiply by 2
f_colStart(int block) => block * 2

//──────────────────────────────────────────────────────────────────────────────
// 12.5 MODULE DATA PREPARATION
// Placeholders / aggregates (to be wired to engines elsewhere)

//──────────────────────────────────────────────────────────────────────────────
// LONG CONFLUENCE
string long_title = csmLongName == "" ? "Long Confluence" : csmLongName
string long_cur   = str.format("{0} ({1})", _kb_longScore, _kb_longGrade)

float _longCMinPct = gradeC_long != 0 ? math.round(100.0 * _kb_longScore / gradeC_long) : na
float _longBMinPct = gradeB_long != 0 ? math.round(100.0 * _kb_longScore / gradeB_long) : na
float _longAMinPct = gradeA_long != 0 ? math.round(100.0 * _kb_longScore / gradeA_long) : na

string long_cmin  = str.format("{0} ({1}%)", gradeC_long, _longCMinPct)
string long_bmin  = str.format("{0} ({1}%)", gradeB_long, _longBMinPct)
string long_amin  = str.format("{0} ({1}%)", gradeA_long, _longAMinPct)


// SHORT CONFLUENCE
string short_title = csmShortName == "" ? "Short Confluence" : csmShortName
string short_cur   = str.format("{0} ({1})", _kb_shortScore, _kb_shortGrade)

float _shortCMinPct = gradeC_short != 0 ? math.round(100.0 * _kb_shortScore / gradeC_short) : na
float _shortBMinPct = gradeB_short != 0 ? math.round(100.0 * _kb_shortScore / gradeB_short) : na
float _shortAMinPct = gradeA_short != 0 ? math.round(100.0 * _kb_shortScore / gradeA_short) : na

string short_cmin  = str.format("{0} ({1}%)", gradeC_short, _shortCMinPct)
string short_bmin  = str.format("{0} ({1}%)", gradeB_short, _shortBMinPct)
string short_amin  = str.format("{0} ({1}%)", gradeA_short, _shortAMinPct)


// POSITION SIZING
string sizer_title = sizerName == "" ? "Position Sizing" : sizerName
string s_slMethod  = sl_method
float s_slPrice    = na
if sl_method == "ATR"
    s_slPrice := close - ta.atr(sl_atrPer) * sl_atrMult
else if sl_method == "Fixed Dollar"
    s_slPrice := close - sl_fixed
else if sl_method == "Percentage"
    s_slPrice := close * (1 - sl_pct * 0.01)
else if sl_method == "Candle Wicks"
    s_slPrice := low[sl_lookback] - sl_pad
string s_SL = str.tostring(s_slPrice)

float ps_qty = _kb_calcQty(close, 1)  // Display uses long direction by default
string s_QTY = str.tostring(ps_qty)
string s_RISK = riskMode == "Share Qty" ? "Shares" : riskMode == "Fixed $ Risk" ? str.tostring(defRisk) : str.tostring(defRiskPct) + "%"

// BACKTEST KPIs
string back_title = backName == "" ? "Backtest KPIs" : backName
float wr = bt_totalTrades > 0 ? 100.0 * bt_winCount / bt_totalTrades : 0
string bt_wr = str.format("{0,number,#.##}%", wr)
float pf = na
if bt_grossLoss != 0
    float _pfDenom = math.max(math.abs(bt_grossLoss), 0.0000001)
    pf := bt_grossWin / _pfDenom
string bt_pf = str.tostring(pf)
string bt_dd = str.format("{0,number,#.##}%", 100.0 * bt_maxDrawdown)
string bt_tr = str.tostring(bt_totalTrades)

// TOP MODULE 1 (External Library)
string top1_title = top1_name
string top1A = str.tostring(top1_raw.outA)
string top1B = str.tostring(top1_raw.outB)
string top1C = str.tostring(top1_raw.outC)
string top1D = str.tostring(top1_raw.outD)

// VWAP TOP MODULE (Confluence Interpreter)
string vwap_title = lib_vwap_name == "" ? "VWAP" : lib_vwap_name
int _vwap_totalScore = _vwap_longScore + _vwap_shortScore

// Calculate cell colors based on condition matches
color vwap_D_bg = f_vwapCell_color(lib_vwap_D_zone, lib_vwap_D_long, lib_vwap_D_short, lib_vwap_D_score)
color vwap_W_bg = f_vwapCell_color(lib_vwap_W_zone, lib_vwap_W_long, lib_vwap_W_short, lib_vwap_W_score)
color vwap_M_bg = f_vwapCell_color(lib_vwap_M_zone, lib_vwap_M_long, lib_vwap_M_short, lib_vwap_M_score)

//──────────────────────────────────────────────────────────────────────────────
// 12.6 RENDERING
//──────────────────────────────────────────────────────────────────────────────

renderModule(int block, string title, string r1name, string r1val, string r2name, string r2val, string r3name, string r3val, string r4name, string r4val) =>
    int c = f_colStart(block)
    table.cell(kbTopTable, c,   0, title, text_color=_kb_headTxt, bgcolor=_kb_headBg)
    table.cell(kbTopTable, c+1, 0, "",     text_color=_kb_headTxt, bgcolor=_kb_headBg)
    table.cell(kbTopTable, c,   1, r1name, text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 1, r1val,  text_color=_kb_valTxt,  bgcolor=_kb_valBg)
    table.cell(kbTopTable, c,   2, r2name, text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 2, r2val,  text_color=_kb_valTxt,  bgcolor=_kb_valBg)
    table.cell(kbTopTable, c,   3, r3name, text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 3, r3val,  text_color=_kb_valTxt,  bgcolor=_kb_valBg)
    table.cell(kbTopTable, c,   4, r4name, text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 4, r4val,  text_color=_kb_valTxt,  bgcolor=_kb_valBg)

// Custom render function for VWAP with per-cell color coding (confluence interpreter = purple header)
renderModuleVWAP(int block, string title,
                 string r1val, color r1bg,
                 string r2val, color r2bg,
                 string r3val, color r3bg,
                 string r4val) =>
    int c = f_colStart(block)
    table.cell(kbTopTable, c,   0, title,    text_color=_kb_headTxt, bgcolor=_kb_confHeadBg)
    table.cell(kbTopTable, c+1, 0, "",       text_color=_kb_headTxt, bgcolor=_kb_confHeadBg)
    table.cell(kbTopTable, c,   1, "Daily",  text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 1, r1val,    text_color=_kb_valTxt,  bgcolor=r1bg)
    table.cell(kbTopTable, c,   2, "Weekly", text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 2, r2val,    text_color=_kb_valTxt,  bgcolor=r2bg)
    table.cell(kbTopTable, c,   3, "Monthly",text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 3, r3val,    text_color=_kb_valTxt,  bgcolor=r3bg)
    table.cell(kbTopTable, c,   4, "Score",  text_color=_kb_labTxt,  bgcolor=_kb_labBg)
    table.cell(kbTopTable, c+1, 4, r4val,    text_color=_kb_valTxt,  bgcolor=_kb_valBg)

if enableTopTable and barstate.islast
    if useLongCSM
        renderModule(colLong, long_title, "Current", long_cur, "C Min", long_cmin, "B Min", long_bmin, "A Min", long_amin)
    if useShortCSM
        renderModule(colShort, short_title, "Current", short_cur, "C Min", short_cmin, "B Min", short_bmin, "A Min", short_amin)
    if useSizer
        renderModule(colSizer, sizer_title, "SL Method", s_slMethod, "SL Price", s_SL, "Risk", s_RISK, "Qty", s_QTY)
    if useBacktest
        renderModule(colBack, back_title, "WR", bt_wr, "PF", bt_pf, "Drawdown", bt_dd, "Trades", bt_tr)
    if useTop1
        renderModule(colTop1, top1_title, "Output A", top1A, "Output B", top1B, "Output C", top1C, "Output D", top1D)
    if useTopVWAP
        renderModuleVWAP(colTopVWAP, vwap_title,
                         lib_vwap_D_zone, vwap_D_bg,
                         lib_vwap_W_zone, vwap_W_bg,
                         lib_vwap_M_zone, vwap_M_bg,
                         str.tostring(_vwap_totalScore))

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 13. SIDE TABLE RENDERER (Side Module 1 – Timeframe-Based)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// 13.1 Side Table Settings

string GRP_SIDE_TABLE = "13. Side Table (Timeframe Grid)"

string sideTable_position = input.string(
     "Middle Right",
     "Side Table Position",
     options = ["Top Right", "Middle Right", "Bottom Right"],
     group   = GRP_SIDE_TABLE,
     tooltip = "Choose where to render the Side (timeframe) table."
)

// Resolve table position ------------------------------------------------------
f_sideTable_pos(string posLabel) =>
     posLabel == "Top Right"   ? position.top_right :
     posLabel == "Middle Right"? position.middle_right : position.bottom_right

// 13.2 Per‑TF Color Logic (Theme-Aware) ----------------------------------------

// Theme-aware transparency levels
int _kb_sideTrans     = useDarkTheme ? 75 : 85
int _kb_sideTransOff  = useDarkTheme ? 85 : 90
color _kb_sideTxtCol  = useDarkTheme ? color.white : color.new(color.black, 0)
color _kb_sideHeadBg  = useDarkTheme ? color.new(color.gray, 65) : color.new(color.gray, 85)
color _kb_sideLabelBg = useDarkTheme ? color.new(color.gray, 75) : color.new(color.gray, 88)

f_sideTF_color(bool tfCondLE, bool tfCondSE, bool leScope, bool seScope, int leScore, int seScore) =>
    bool hasLongScope  = leScope  and leScore > 0
    bool hasShortScope = seScope and seScore > 0
    bool anyScope      = hasLongScope or hasShortScope

    // Evaluate Long and Short conditions independently
    bool longTrue  = hasLongScope  and tfCondLE
    bool shortTrue = hasShortScope and tfCondSE

    // Color priority (lowest to highest): Gray -> Yellow -> Green/Red -> Blue
    color bg = color.new(color.gray, _kb_sideTransOff)

    if anyScope
        if longTrue and shortTrue
            bg := color.new(color.blue, _kb_sideTrans)    // Both confluences TRUE
        else if longTrue
            bg := color.new(color.green, _kb_sideTrans)   // Long confluence TRUE
        else if shortTrue
            bg := color.new(color.red, _kb_sideTrans)     // Short confluence TRUE
        else
            bg := color.new(color.yellow, _kb_sideTrans)  // Monitored but not met
    bg

// 13.3 Build Timeframe Columns -----------------------------------------------
// Use KevBot_TimeUtils library for formatting

tf_fmt_tf(string tf) => tu.tu_fmt(tf)

string[] _kb_side_tfLabels = array.new_string()
int[]    _kb_side_tfIndex  = array.new_int()

// Push enabled TFs into the arrays
f_push_tf(bool enabled, string rawTf, int idx) =>
    if enabled
        // Treat empty/Chart consistently so library can resolve timeframe.period
        string safeTf = (rawTf == "" or rawTf == "Chart") ? "Chart" : rawTf
        array.push(_kb_side_tfLabels, tf_fmt_tf(safeTf))
        array.push(_kb_side_tfIndex,  idx)

// Collect only enabled TFs (TF1..TF6) in order.
f_push_tf(tf1_enabled, tf1, 1)
f_push_tf(tf2_enabled, tf2, 2)
f_push_tf(tf3_enabled, tf3, 3)
f_push_tf(tf4_enabled, tf4, 4)
f_push_tf(tf5_enabled, tf5, 5)
f_push_tf(tf6_enabled, tf6, 6)

int _kb_side_tfCount = array.size(_kb_side_tfLabels)
// LOCKED COLUMN MODE (workaround): always 7 columns
// 1 Indicator + 6 TF columns
int _kb_colCount = 7

var table _kb_sideTable = na
var int   _kb_sideCols  = 0

// Hard-reset table if column count changes
if enableSideTable and not na(_kb_sideTable) and _kb_sideCols != _kb_colCount
    table.delete(_kb_sideTable)
    _kb_sideTable := na
    _kb_sideCols  := 0

// Create table if needed (11 rows: 1 header + 10 possible library rows)
// V2 architecture uses slots 1-10 for library-centric rendering
if enableSideTable and na(_kb_sideTable)
    _kb_sideTable := table.new(
        f_sideTable_pos(sideTable_position),
        _kb_colCount,
        11,
        frame_width = 1,
        bgcolor     = color.new(color.gray, 80)
    )
    _kb_sideCols := _kb_colCount

// 13.4.1 Safe cell wrapper ----------------------------------------------------

f_sideTable_cell(table t, int col, int row, string txt, color txtCol, color bgCol) =>
    if not na(t) and col >= 0 and col < _kb_sideCols
        table.cell(t, col, row, txt, text_color = txtCol, bgcolor = bgCol)

// 13.5 Header Row -------------------------------------------------------------

int _kb_headerRow = 0

// Indicator column header
if enableSideTable
    f_sideTable_cell(_kb_sideTable, 0, _kb_headerRow, "Indicator", _kb_sideTxtCol, _kb_sideHeadBg)

    // Timeframe headers (TF1..TFN)
    for i = 0 to _kb_side_tfCount - 1
        string tfLabel = array.get(_kb_side_tfLabels, i)
        int    col     = 1 + i
        f_sideTable_cell(_kb_sideTable, col, _kb_headerRow, tfLabel, _kb_sideTxtCol, _kb_sideHeadBg)

    // Clear any unused header cells beyond active TF count
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _kb_headerRow, "", _kb_sideTxtCol, color.new(color.gray, 100))

//──────────────────────────────────────────────────────────────────────────────
// 13.6 V2 LIBRARY ROWS (Slot-Based Rendering)
//──────────────────────────────────────────────────────────────────────────────
// Libraries with slot > 0 are rendered in slot order (row = slot)
// Slot 1 = row 1, Slot 2 = row 2, etc. (row 0 is header)
//──────────────────────────────────────────────────────────────────────────────

// --- EMA Stack Row (renders if lib_ema_slot > 0) ---
if enableSideTable and lib_ema_enabled and lib_ema_slot > 0 and _kb_side_tfCount > 0
    int _ema_row = lib_ema_slot  // Slot 1 = row 1, etc.

    // Library label (leftmost column)
    f_sideTable_cell(_kb_sideTable, 0, _ema_row, lib_ema_name, _kb_sideTxtCol, _kb_sideLabelBg)

    // Get condition indices
    int _ema_LE_condIdx = _kb_mapCondSource(lib_ema_LEC_func)
    int _ema_SE_condIdx = _kb_mapCondSource(lib_ema_SEC_func)

    // Per-TF cells
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col   = 1 + i

        int  leScore   = 0
        int  seScore   = 0
        bool tfCondLE  = false
        bool tfCondSE  = false
        string tfLabel = ""
        bool reqLong   = false
        bool reqShort  = false

        // Extract TF-specific metadata from lib_ema_v2
        if tfIdx == 1
            leScore  := lib_ema_LE_tf1
            seScore  := lib_ema_SE_tf1
            tfCondLE := _kb_getCondTF1(lib_ema_v2, _ema_LE_condIdx)
            tfCondSE := _kb_getCondTF1(lib_ema_v2, _ema_SE_condIdx)
            tfLabel  := lib_ema_v2.tf1_label
            reqLong  := lib_ema_LE_tf1_req
            reqShort := lib_ema_SE_tf1_req
        else if tfIdx == 2
            leScore  := lib_ema_LE_tf2
            seScore  := lib_ema_SE_tf2
            tfCondLE := _kb_getCondTF2(lib_ema_v2, _ema_LE_condIdx)
            tfCondSE := _kb_getCondTF2(lib_ema_v2, _ema_SE_condIdx)
            tfLabel  := lib_ema_v2.tf2_label
            reqLong  := lib_ema_LE_tf2_req
            reqShort := lib_ema_SE_tf2_req
        else if tfIdx == 3
            leScore  := lib_ema_LE_tf3
            seScore  := lib_ema_SE_tf3
            tfCondLE := _kb_getCondTF3(lib_ema_v2, _ema_LE_condIdx)
            tfCondSE := _kb_getCondTF3(lib_ema_v2, _ema_SE_condIdx)
            tfLabel  := lib_ema_v2.tf3_label
            reqLong  := lib_ema_LE_tf3_req
            reqShort := lib_ema_SE_tf3_req
        else if tfIdx == 4
            leScore  := lib_ema_LE_tf4
            seScore  := lib_ema_SE_tf4
            tfCondLE := _kb_getCondTF4(lib_ema_v2, _ema_LE_condIdx)
            tfCondSE := _kb_getCondTF4(lib_ema_v2, _ema_SE_condIdx)
            tfLabel  := lib_ema_v2.tf4_label
            reqLong  := lib_ema_LE_tf4_req
            reqShort := lib_ema_SE_tf4_req
        else if tfIdx == 5
            leScore  := lib_ema_LE_tf5
            seScore  := lib_ema_SE_tf5
            tfCondLE := _kb_getCondTF5(lib_ema_v2, _ema_LE_condIdx)
            tfCondSE := _kb_getCondTF5(lib_ema_v2, _ema_SE_condIdx)
            tfLabel  := lib_ema_v2.tf5_label
            reqLong  := lib_ema_LE_tf5_req
            reqShort := lib_ema_SE_tf5_req
        else if tfIdx == 6
            leScore  := lib_ema_LE_tf6
            seScore  := lib_ema_SE_tf6
            tfCondLE := _kb_getCondTF6(lib_ema_v2, _ema_LE_condIdx)
            tfCondSE := _kb_getCondTF6(lib_ema_v2, _ema_SE_condIdx)
            tfLabel  := lib_ema_v2.tf6_label
            reqLong  := lib_ema_LE_tf6_req
            reqShort := lib_ema_SE_tf6_req

        // Determine if confluence is enabled for both LE and SE
        bool leScope = lib_ema_LEC_enable
        bool seScope = lib_ema_SEC_enable

        // Cell background color
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, leScope, seScope, leScore, seScore)

        bool isRequired = (reqLong and leScore > 0) or (reqShort and seScore > 0)

        string baseLabel = tfLabel != "" ? tfLabel : "-"
        string cellText  = isRequired ? baseLabel + " (R)" : baseLabel

        f_sideTable_cell(_kb_sideTable, col, _ema_row, cellText, _kb_sideTxtCol, cellBg)

    // Clear any unused cells beyond active TF count
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _ema_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

else if enableSideTable and lib_ema_slot > 0
    // Clear the EMA row if library is disabled but slot is assigned
    int _ema_row = lib_ema_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _ema_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

// --- RVOL Row (renders if lib_rvol_slot > 0) ---
if enableSideTable and lib_rvol_enabled and lib_rvol_slot > 0 and _kb_side_tfCount > 0
    int _rvol_row = lib_rvol_slot  // Slot 1 = row 1, etc.

    // Library label (leftmost column)
    f_sideTable_cell(_kb_sideTable, 0, _rvol_row, lib_rvol_name, _kb_sideTxtCol, _kb_sideLabelBg)

    // Get condition indices
    int _rvol_LE_condIdx = _kb_mapCondSource(lib_rvol_LEC_func)
    int _rvol_SE_condIdx = _kb_mapCondSource(lib_rvol_SEC_func)

    // Per-TF cells
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col   = 1 + i

        int  leScore   = 0
        int  seScore   = 0
        bool tfCondLE  = false
        bool tfCondSE  = false
        string tfLabel = ""
        bool reqLong   = false
        bool reqShort  = false

        // Extract TF-specific metadata from lib_rvol_v2
        if tfIdx == 1
            leScore  := lib_rvol_LE_tf1
            seScore  := lib_rvol_SE_tf1
            tfCondLE := _kb_getCondTF1(lib_rvol_v2, _rvol_LE_condIdx)
            tfCondSE := _kb_getCondTF1(lib_rvol_v2, _rvol_SE_condIdx)
            tfLabel  := lib_rvol_v2.tf1_label
            reqLong  := lib_rvol_LE_tf1_req
            reqShort := lib_rvol_SE_tf1_req
        else if tfIdx == 2
            leScore  := lib_rvol_LE_tf2
            seScore  := lib_rvol_SE_tf2
            tfCondLE := _kb_getCondTF2(lib_rvol_v2, _rvol_LE_condIdx)
            tfCondSE := _kb_getCondTF2(lib_rvol_v2, _rvol_SE_condIdx)
            tfLabel  := lib_rvol_v2.tf2_label
            reqLong  := lib_rvol_LE_tf2_req
            reqShort := lib_rvol_SE_tf2_req
        else if tfIdx == 3
            leScore  := lib_rvol_LE_tf3
            seScore  := lib_rvol_SE_tf3
            tfCondLE := _kb_getCondTF3(lib_rvol_v2, _rvol_LE_condIdx)
            tfCondSE := _kb_getCondTF3(lib_rvol_v2, _rvol_SE_condIdx)
            tfLabel  := lib_rvol_v2.tf3_label
            reqLong  := lib_rvol_LE_tf3_req
            reqShort := lib_rvol_SE_tf3_req
        else if tfIdx == 4
            leScore  := lib_rvol_LE_tf4
            seScore  := lib_rvol_SE_tf4
            tfCondLE := _kb_getCondTF4(lib_rvol_v2, _rvol_LE_condIdx)
            tfCondSE := _kb_getCondTF4(lib_rvol_v2, _rvol_SE_condIdx)
            tfLabel  := lib_rvol_v2.tf4_label
            reqLong  := lib_rvol_LE_tf4_req
            reqShort := lib_rvol_SE_tf4_req
        else if tfIdx == 5
            leScore  := lib_rvol_LE_tf5
            seScore  := lib_rvol_SE_tf5
            tfCondLE := _kb_getCondTF5(lib_rvol_v2, _rvol_LE_condIdx)
            tfCondSE := _kb_getCondTF5(lib_rvol_v2, _rvol_SE_condIdx)
            tfLabel  := lib_rvol_v2.tf5_label
            reqLong  := lib_rvol_LE_tf5_req
            reqShort := lib_rvol_SE_tf5_req
        else if tfIdx == 6
            leScore  := lib_rvol_LE_tf6
            seScore  := lib_rvol_SE_tf6
            tfCondLE := _kb_getCondTF6(lib_rvol_v2, _rvol_LE_condIdx)
            tfCondSE := _kb_getCondTF6(lib_rvol_v2, _rvol_SE_condIdx)
            tfLabel  := lib_rvol_v2.tf6_label
            reqLong  := lib_rvol_LE_tf6_req
            reqShort := lib_rvol_SE_tf6_req

        // Determine if confluence is enabled for both LE and SE
        bool leScope = lib_rvol_LEC_enable
        bool seScope = lib_rvol_SEC_enable

        // Cell background color
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, leScope, seScope, leScore, seScore)

        bool isRequired = (reqLong and leScore > 0) or (reqShort and seScore > 0)

        string baseLabel = tfLabel != "" ? tfLabel : "-"
        string cellText  = isRequired ? baseLabel + " (R)" : baseLabel

        f_sideTable_cell(_kb_sideTable, col, _rvol_row, cellText, _kb_sideTxtCol, cellBg)

    // Clear any unused cells beyond active TF count
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _rvol_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

else if enableSideTable and lib_rvol_slot > 0
    // Clear the RVOL row if library is disabled but slot is assigned
    int _rvol_row = lib_rvol_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _rvol_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

// --- UT BOT Row ---
if enableSideTable and lib_utbot_enabled and lib_utbot_slot > 0 and _kb_side_tfCount > 0
    int _utbot_row = lib_utbot_slot
    f_sideTable_cell(_kb_sideTable, 0, _utbot_row, lib_utbot_name, _kb_sideTxtCol, _kb_sideLabelBg)
    int _utbot_LE_condIdx = _kb_mapCondSource(lib_utbot_LEC_func)
    int _utbot_SE_condIdx = _kb_mapCondSource(lib_utbot_SEC_func)
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col = 1 + i
        int leScore = tfIdx == 1 ? lib_utbot_LE_tf1 : tfIdx == 2 ? lib_utbot_LE_tf2 : tfIdx == 3 ? lib_utbot_LE_tf3 : tfIdx == 4 ? lib_utbot_LE_tf4 : tfIdx == 5 ? lib_utbot_LE_tf5 : lib_utbot_LE_tf6
        int seScore = tfIdx == 1 ? lib_utbot_SE_tf1 : tfIdx == 2 ? lib_utbot_SE_tf2 : tfIdx == 3 ? lib_utbot_SE_tf3 : tfIdx == 4 ? lib_utbot_SE_tf4 : tfIdx == 5 ? lib_utbot_SE_tf5 : lib_utbot_SE_tf6
        bool reqLong = tfIdx == 1 ? lib_utbot_LE_tf1_req : tfIdx == 2 ? lib_utbot_LE_tf2_req : tfIdx == 3 ? lib_utbot_LE_tf3_req : tfIdx == 4 ? lib_utbot_LE_tf4_req : tfIdx == 5 ? lib_utbot_LE_tf5_req : lib_utbot_LE_tf6_req
        bool reqShort = tfIdx == 1 ? lib_utbot_SE_tf1_req : tfIdx == 2 ? lib_utbot_SE_tf2_req : tfIdx == 3 ? lib_utbot_SE_tf3_req : tfIdx == 4 ? lib_utbot_SE_tf4_req : tfIdx == 5 ? lib_utbot_SE_tf5_req : lib_utbot_SE_tf6_req
        bool tfCondLE = tfIdx == 1 ? _kb_getCondTF1(lib_utbot_v2, _utbot_LE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_utbot_v2, _utbot_LE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_utbot_v2, _utbot_LE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_utbot_v2, _utbot_LE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_utbot_v2, _utbot_LE_condIdx) : _kb_getCondTF6(lib_utbot_v2, _utbot_LE_condIdx)
        bool tfCondSE = tfIdx == 1 ? _kb_getCondTF1(lib_utbot_v2, _utbot_SE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_utbot_v2, _utbot_SE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_utbot_v2, _utbot_SE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_utbot_v2, _utbot_SE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_utbot_v2, _utbot_SE_condIdx) : _kb_getCondTF6(lib_utbot_v2, _utbot_SE_condIdx)
        string tfLabel = tfIdx == 1 ? lib_utbot_v2.tf1_label : tfIdx == 2 ? lib_utbot_v2.tf2_label : tfIdx == 3 ? lib_utbot_v2.tf3_label : tfIdx == 4 ? lib_utbot_v2.tf4_label : tfIdx == 5 ? lib_utbot_v2.tf5_label : lib_utbot_v2.tf6_label
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, lib_utbot_LEC_enable, lib_utbot_SEC_enable, leScore, seScore)
        bool isReq = (reqLong and leScore > 0) or (reqShort and seScore > 0)
        string cellText = isReq ? (tfLabel != "" ? tfLabel + " (R)" : "- (R)") : (tfLabel != "" ? tfLabel : "-")
        f_sideTable_cell(_kb_sideTable, col, _utbot_row, cellText, _kb_sideTxtCol, cellBg)
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _utbot_row, "", _kb_sideTxtCol, color.new(color.gray, 100))
else if enableSideTable and lib_utbot_slot > 0
    int _utbot_row = lib_utbot_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _utbot_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

// --- SWING 123 Row ---
if enableSideTable and lib_swing_enabled and lib_swing_slot > 0 and _kb_side_tfCount > 0
    int _swing_row = lib_swing_slot
    f_sideTable_cell(_kb_sideTable, 0, _swing_row, lib_swing_name, _kb_sideTxtCol, _kb_sideLabelBg)
    int _swing_LE_condIdx = _kb_mapCondSource(lib_swing_LEC_func)
    int _swing_SE_condIdx = _kb_mapCondSource(lib_swing_SEC_func)
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col = 1 + i
        int leScore = tfIdx == 1 ? lib_swing_LE_tf1 : tfIdx == 2 ? lib_swing_LE_tf2 : tfIdx == 3 ? lib_swing_LE_tf3 : tfIdx == 4 ? lib_swing_LE_tf4 : tfIdx == 5 ? lib_swing_LE_tf5 : lib_swing_LE_tf6
        int seScore = tfIdx == 1 ? lib_swing_SE_tf1 : tfIdx == 2 ? lib_swing_SE_tf2 : tfIdx == 3 ? lib_swing_SE_tf3 : tfIdx == 4 ? lib_swing_SE_tf4 : tfIdx == 5 ? lib_swing_SE_tf5 : lib_swing_SE_tf6
        bool reqLong = tfIdx == 1 ? lib_swing_LE_tf1_req : tfIdx == 2 ? lib_swing_LE_tf2_req : tfIdx == 3 ? lib_swing_LE_tf3_req : tfIdx == 4 ? lib_swing_LE_tf4_req : tfIdx == 5 ? lib_swing_LE_tf5_req : lib_swing_LE_tf6_req
        bool reqShort = tfIdx == 1 ? lib_swing_SE_tf1_req : tfIdx == 2 ? lib_swing_SE_tf2_req : tfIdx == 3 ? lib_swing_SE_tf3_req : tfIdx == 4 ? lib_swing_SE_tf4_req : tfIdx == 5 ? lib_swing_SE_tf5_req : lib_swing_SE_tf6_req
        bool tfCondLE = tfIdx == 1 ? _kb_getCondTF1(lib_swing_v2, _swing_LE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_swing_v2, _swing_LE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_swing_v2, _swing_LE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_swing_v2, _swing_LE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_swing_v2, _swing_LE_condIdx) : _kb_getCondTF6(lib_swing_v2, _swing_LE_condIdx)
        bool tfCondSE = tfIdx == 1 ? _kb_getCondTF1(lib_swing_v2, _swing_SE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_swing_v2, _swing_SE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_swing_v2, _swing_SE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_swing_v2, _swing_SE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_swing_v2, _swing_SE_condIdx) : _kb_getCondTF6(lib_swing_v2, _swing_SE_condIdx)
        string tfLabel = tfIdx == 1 ? lib_swing_v2.tf1_label : tfIdx == 2 ? lib_swing_v2.tf2_label : tfIdx == 3 ? lib_swing_v2.tf3_label : tfIdx == 4 ? lib_swing_v2.tf4_label : tfIdx == 5 ? lib_swing_v2.tf5_label : lib_swing_v2.tf6_label
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, lib_swing_LEC_enable, lib_swing_SEC_enable, leScore, seScore)
        bool isReq = (reqLong and leScore > 0) or (reqShort and seScore > 0)
        string cellText = isReq ? (tfLabel != "" ? tfLabel + " (R)" : "- (R)") : (tfLabel != "" ? tfLabel : "-")
        f_sideTable_cell(_kb_sideTable, col, _swing_row, cellText, _kb_sideTxtCol, cellBg)
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _swing_row, "", _kb_sideTxtCol, color.new(color.gray, 100))
else if enableSideTable and lib_swing_slot > 0
    int _swing_row = lib_swing_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _swing_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

// --- MACD LINE Row ---
if enableSideTable and lib_macdl_enabled and lib_macdl_slot > 0 and _kb_side_tfCount > 0
    int _macdl_row = lib_macdl_slot
    f_sideTable_cell(_kb_sideTable, 0, _macdl_row, lib_macdl_name, _kb_sideTxtCol, _kb_sideLabelBg)
    int _macdl_LE_condIdx = _kb_mapCondSource(lib_macdl_LEC_func)
    int _macdl_SE_condIdx = _kb_mapCondSource(lib_macdl_SEC_func)
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col = 1 + i
        int leScore = tfIdx == 1 ? lib_macdl_LE_tf1 : tfIdx == 2 ? lib_macdl_LE_tf2 : tfIdx == 3 ? lib_macdl_LE_tf3 : tfIdx == 4 ? lib_macdl_LE_tf4 : tfIdx == 5 ? lib_macdl_LE_tf5 : lib_macdl_LE_tf6
        int seScore = tfIdx == 1 ? lib_macdl_SE_tf1 : tfIdx == 2 ? lib_macdl_SE_tf2 : tfIdx == 3 ? lib_macdl_SE_tf3 : tfIdx == 4 ? lib_macdl_SE_tf4 : tfIdx == 5 ? lib_macdl_SE_tf5 : lib_macdl_SE_tf6
        bool reqLong = tfIdx == 1 ? lib_macdl_LE_tf1_req : tfIdx == 2 ? lib_macdl_LE_tf2_req : tfIdx == 3 ? lib_macdl_LE_tf3_req : tfIdx == 4 ? lib_macdl_LE_tf4_req : tfIdx == 5 ? lib_macdl_LE_tf5_req : lib_macdl_LE_tf6_req
        bool reqShort = tfIdx == 1 ? lib_macdl_SE_tf1_req : tfIdx == 2 ? lib_macdl_SE_tf2_req : tfIdx == 3 ? lib_macdl_SE_tf3_req : tfIdx == 4 ? lib_macdl_SE_tf4_req : tfIdx == 5 ? lib_macdl_SE_tf5_req : lib_macdl_SE_tf6_req
        bool tfCondLE = tfIdx == 1 ? _kb_getCondTF1(lib_macdl_v2, _macdl_LE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_macdl_v2, _macdl_LE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_macdl_v2, _macdl_LE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_macdl_v2, _macdl_LE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_macdl_v2, _macdl_LE_condIdx) : _kb_getCondTF6(lib_macdl_v2, _macdl_LE_condIdx)
        bool tfCondSE = tfIdx == 1 ? _kb_getCondTF1(lib_macdl_v2, _macdl_SE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_macdl_v2, _macdl_SE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_macdl_v2, _macdl_SE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_macdl_v2, _macdl_SE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_macdl_v2, _macdl_SE_condIdx) : _kb_getCondTF6(lib_macdl_v2, _macdl_SE_condIdx)
        string tfLabel = tfIdx == 1 ? lib_macdl_v2.tf1_label : tfIdx == 2 ? lib_macdl_v2.tf2_label : tfIdx == 3 ? lib_macdl_v2.tf3_label : tfIdx == 4 ? lib_macdl_v2.tf4_label : tfIdx == 5 ? lib_macdl_v2.tf5_label : lib_macdl_v2.tf6_label
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, lib_macdl_LEC_enable, lib_macdl_SEC_enable, leScore, seScore)
        bool isReq = (reqLong and leScore > 0) or (reqShort and seScore > 0)
        string cellText = isReq ? (tfLabel != "" ? tfLabel + " (R)" : "- (R)") : (tfLabel != "" ? tfLabel : "-")
        f_sideTable_cell(_kb_sideTable, col, _macdl_row, cellText, _kb_sideTxtCol, cellBg)
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _macdl_row, "", _kb_sideTxtCol, color.new(color.gray, 100))
else if enableSideTable and lib_macdl_slot > 0
    int _macdl_row = lib_macdl_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _macdl_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

// --- MACD HISTOGRAM Row ---
if enableSideTable and lib_macdh_enabled and lib_macdh_slot > 0 and _kb_side_tfCount > 0
    int _macdh_row = lib_macdh_slot
    f_sideTable_cell(_kb_sideTable, 0, _macdh_row, lib_macdh_name, _kb_sideTxtCol, _kb_sideLabelBg)
    int _macdh_LE_condIdx = _kb_mapCondSource(lib_macdh_LEC_func)
    int _macdh_SE_condIdx = _kb_mapCondSource(lib_macdh_SEC_func)
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col = 1 + i
        int leScore = tfIdx == 1 ? lib_macdh_LE_tf1 : tfIdx == 2 ? lib_macdh_LE_tf2 : tfIdx == 3 ? lib_macdh_LE_tf3 : tfIdx == 4 ? lib_macdh_LE_tf4 : tfIdx == 5 ? lib_macdh_LE_tf5 : lib_macdh_LE_tf6
        int seScore = tfIdx == 1 ? lib_macdh_SE_tf1 : tfIdx == 2 ? lib_macdh_SE_tf2 : tfIdx == 3 ? lib_macdh_SE_tf3 : tfIdx == 4 ? lib_macdh_SE_tf4 : tfIdx == 5 ? lib_macdh_SE_tf5 : lib_macdh_SE_tf6
        bool reqLong = tfIdx == 1 ? lib_macdh_LE_tf1_req : tfIdx == 2 ? lib_macdh_LE_tf2_req : tfIdx == 3 ? lib_macdh_LE_tf3_req : tfIdx == 4 ? lib_macdh_LE_tf4_req : tfIdx == 5 ? lib_macdh_LE_tf5_req : lib_macdh_LE_tf6_req
        bool reqShort = tfIdx == 1 ? lib_macdh_SE_tf1_req : tfIdx == 2 ? lib_macdh_SE_tf2_req : tfIdx == 3 ? lib_macdh_SE_tf3_req : tfIdx == 4 ? lib_macdh_SE_tf4_req : tfIdx == 5 ? lib_macdh_SE_tf5_req : lib_macdh_SE_tf6_req
        bool tfCondLE = tfIdx == 1 ? _kb_getCondTF1(lib_macdh_v2, _macdh_LE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_macdh_v2, _macdh_LE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_macdh_v2, _macdh_LE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_macdh_v2, _macdh_LE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_macdh_v2, _macdh_LE_condIdx) : _kb_getCondTF6(lib_macdh_v2, _macdh_LE_condIdx)
        bool tfCondSE = tfIdx == 1 ? _kb_getCondTF1(lib_macdh_v2, _macdh_SE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_macdh_v2, _macdh_SE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_macdh_v2, _macdh_SE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_macdh_v2, _macdh_SE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_macdh_v2, _macdh_SE_condIdx) : _kb_getCondTF6(lib_macdh_v2, _macdh_SE_condIdx)
        string tfLabel = tfIdx == 1 ? lib_macdh_v2.tf1_label : tfIdx == 2 ? lib_macdh_v2.tf2_label : tfIdx == 3 ? lib_macdh_v2.tf3_label : tfIdx == 4 ? lib_macdh_v2.tf4_label : tfIdx == 5 ? lib_macdh_v2.tf5_label : lib_macdh_v2.tf6_label
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, lib_macdh_LEC_enable, lib_macdh_SEC_enable, leScore, seScore)
        bool isReq = (reqLong and leScore > 0) or (reqShort and seScore > 0)
        string cellText = isReq ? (tfLabel != "" ? tfLabel + " (R)" : "- (R)") : (tfLabel != "" ? tfLabel : "-")
        f_sideTable_cell(_kb_sideTable, col, _macdh_row, cellText, _kb_sideTxtCol, cellBg)
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _macdh_row, "", _kb_sideTxtCol, color.new(color.gray, 100))
else if enableSideTable and lib_macdh_slot > 0
    int _macdh_row = lib_macdh_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _macdh_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

// --- SIMPLE MACD Row ---
if enableSideTable and lib_macds_enabled and lib_macds_slot > 0 and _kb_side_tfCount > 0
    int _macds_row = lib_macds_slot
    f_sideTable_cell(_kb_sideTable, 0, _macds_row, lib_macds_name, _kb_sideTxtCol, _kb_sideLabelBg)
    int _macds_LE_condIdx = _kb_mapCondSource(lib_macds_LEC_func)
    int _macds_SE_condIdx = _kb_mapCondSource(lib_macds_SEC_func)
    for i = 0 to _kb_side_tfCount - 1
        int tfIdx = array.get(_kb_side_tfIndex, i)
        int col = 1 + i
        int leScore = tfIdx == 1 ? lib_macds_LE_tf1 : tfIdx == 2 ? lib_macds_LE_tf2 : tfIdx == 3 ? lib_macds_LE_tf3 : tfIdx == 4 ? lib_macds_LE_tf4 : tfIdx == 5 ? lib_macds_LE_tf5 : lib_macds_LE_tf6
        int seScore = tfIdx == 1 ? lib_macds_SE_tf1 : tfIdx == 2 ? lib_macds_SE_tf2 : tfIdx == 3 ? lib_macds_SE_tf3 : tfIdx == 4 ? lib_macds_SE_tf4 : tfIdx == 5 ? lib_macds_SE_tf5 : lib_macds_SE_tf6
        bool reqLong = tfIdx == 1 ? lib_macds_LE_tf1_req : tfIdx == 2 ? lib_macds_LE_tf2_req : tfIdx == 3 ? lib_macds_LE_tf3_req : tfIdx == 4 ? lib_macds_LE_tf4_req : tfIdx == 5 ? lib_macds_LE_tf5_req : lib_macds_LE_tf6_req
        bool reqShort = tfIdx == 1 ? lib_macds_SE_tf1_req : tfIdx == 2 ? lib_macds_SE_tf2_req : tfIdx == 3 ? lib_macds_SE_tf3_req : tfIdx == 4 ? lib_macds_SE_tf4_req : tfIdx == 5 ? lib_macds_SE_tf5_req : lib_macds_SE_tf6_req
        bool tfCondLE = tfIdx == 1 ? _kb_getCondTF1(lib_macds_v2, _macds_LE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_macds_v2, _macds_LE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_macds_v2, _macds_LE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_macds_v2, _macds_LE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_macds_v2, _macds_LE_condIdx) : _kb_getCondTF6(lib_macds_v2, _macds_LE_condIdx)
        bool tfCondSE = tfIdx == 1 ? _kb_getCondTF1(lib_macds_v2, _macds_SE_condIdx) : tfIdx == 2 ? _kb_getCondTF2(lib_macds_v2, _macds_SE_condIdx) : tfIdx == 3 ? _kb_getCondTF3(lib_macds_v2, _macds_SE_condIdx) : tfIdx == 4 ? _kb_getCondTF4(lib_macds_v2, _macds_SE_condIdx) : tfIdx == 5 ? _kb_getCondTF5(lib_macds_v2, _macds_SE_condIdx) : _kb_getCondTF6(lib_macds_v2, _macds_SE_condIdx)
        string tfLabel = tfIdx == 1 ? lib_macds_v2.tf1_label : tfIdx == 2 ? lib_macds_v2.tf2_label : tfIdx == 3 ? lib_macds_v2.tf3_label : tfIdx == 4 ? lib_macds_v2.tf4_label : tfIdx == 5 ? lib_macds_v2.tf5_label : lib_macds_v2.tf6_label
        color cellBg = f_sideTF_color(tfCondLE, tfCondSE, lib_macds_LEC_enable, lib_macds_SEC_enable, leScore, seScore)
        bool isReq = (reqLong and leScore > 0) or (reqShort and seScore > 0)
        string cellText = isReq ? (tfLabel != "" ? tfLabel + " (R)" : "- (R)") : (tfLabel != "" ? tfLabel : "-")
        f_sideTable_cell(_kb_sideTable, col, _macds_row, cellText, _kb_sideTxtCol, cellBg)
    for col = 1 + _kb_side_tfCount to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _macds_row, "", _kb_sideTxtCol, color.new(color.gray, 100))
else if enableSideTable and lib_macds_slot > 0
    int _macds_row = lib_macds_slot
    for col = 0 to _kb_sideCols - 1
        f_sideTable_cell(_kb_sideTable, col, _macds_row, "", _kb_sideTxtCol, color.new(color.gray, 100))

//──────────────────────────────────────────────────────────────────────────────
// END V2 LIBRARY ROWS
//──────────────────────────────────────────────────────────────────────────────

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 14. CHART PLOTTING
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// Signal shapes and labels plotted on the chart.
//
// Two categories of signals:
//   1. Raw Triggers (informational) - Cross (+) shape for entries only
//      - Indicates a library trigger fired
//      - Does NOT imply a trade was taken
//   2. Position Signals (actual trades) - Arrow for entries, XCross for exits
//      - Indicates an actual position entry/exit occurred
//
// Note: Raw exit triggers do NOT plot shapes. Exit marks ONLY apply to
// actual position exits since exits only have meaning with an open position.

//──────────────────────────────────────────────────────────────────────────────
// 14.1 RAW TRIGGER MARKS (Entry Only)
//──────────────────────────────────────────────────────────────────────────────
// Cross (+) shape for raw entry triggers - informational only
// Plotted at close price (where trigger is detected)

// Long Entry Raw - Green Cross at close price
plotshape(
     markLongEntry ? close : na,
     title    = "Raw Long Entry",
     style    = shape.cross,
     location = location.absolute,
     color    = color.green,
     size     = size.small,
     display  = display.all
     )

// Short Entry Raw - Red Cross at close price
plotshape(
     markShortEntry ? close : na,
     title    = "Raw Short Entry",
     style    = shape.cross,
     location = location.absolute,
     color    = color.red,
     size     = size.small,
     display  = display.all
     )

// Note: Raw exit triggers (markLongExit, markShortExit) do NOT plot shapes.
// Exit marks only apply to actual position exits.

//──────────────────────────────────────────────────────────────────────────────
// 14.2 POSITION SIGNAL MARKS
//──────────────────────────────────────────────────────────────────────────────
// Triangle shapes for position entries, XCross for position exits
// All plotted at close price (where trigger is detected)

// Long Position Entry - Green Triangle Up at close price
plotshape(
     positionLongEntry ? close : na,
     title    = "Position Long Entry",
     style    = shape.triangleup,
     location = location.absolute,
     color    = color.green,
     size     = size.normal,
     display  = display.all
     )

// Short Position Entry - Red Triangle Down at close price
plotshape(
     positionShortEntry ? close : na,
     title    = "Position Short Entry",
     style    = shape.triangledown,
     location = location.absolute,
     color    = color.red,
     size     = size.normal,
     display  = display.all
     )

// Long Position Exit - Green XCross at close price
plotshape(
     positionLongExit ? close : na,
     title    = "Position Long Exit",
     style    = shape.xcross,
     location = location.absolute,
     color    = color.green,
     size     = size.normal,
     display  = display.all
     )

// Short Position Exit - Red XCross at close price
plotshape(
     positionShortExit ? close : na,
     title    = "Position Short Exit",
     style    = shape.xcross,
     location = location.absolute,
     color    = color.red,
     size     = size.normal,
     display  = display.all
     )

//──────────────────────────────────────────────────────────────────────────────
// 14.3 TRIGGER LABELS
//──────────────────────────────────────────────────────────────────────────────
// Contextual labels showing trigger names and position metadata.
// - Bullish labels: GREEN, BELOW candle (anticipating price up)
// - Bearish labels: RED, ABOVE candle (anticipating price down)

// Helper: Get trigger label for a specific library and trigger index
// Returns descriptive text like "S>M" instead of "Trigger A"
_kb_getTriggerLabel(string library, int trigIdx) =>
    string lbl = ""
    if library == "EMA Stack (S/M/L)"
        // EMA Stack trigger labels
        lbl := trigIdx == 0 ? "S>M" :   // Trigger A: Short crosses above Medium
               trigIdx == 1 ? "S<M" :   // Trigger B: Short crosses below Medium
               trigIdx == 2 ? "S>L" :   // Trigger C: Short crosses above Long
               trigIdx == 3 ? "S<L" :   // Trigger D: Short crosses below Long
               trigIdx == 4 ? "M>L" :   // Trigger E: Medium crosses above Long
               trigIdx == 5 ? "M<L" :   // Trigger F: Medium crosses below Long
               "Trig " + str.tostring(trigIdx)
    else if library == "KevBot_TF_Placeholder"
        lbl := "Trig " + str.tostring(trigIdx)
    else
        lbl := "Trig " + str.tostring(trigIdx)
    lbl

// Helper: Build position label text with metadata
_kb_buildPosLabel(string trigLabel, string grade, string tradeType, float qty, string riskStr) =>
    string txt = trigLabel
    if lbl_type
        txt := txt + "\n" + tradeType
    if lbl_grade
        txt := txt + " | " + grade
    if lbl_qty
        txt := txt + "\nQty: " + str.tostring(qty, "#.##")
    if lbl_risk
        txt := txt + " | $" + riskStr
    txt

// Get trigger labels from v2 libraries
// Uses EMA Stack as primary label source when enabled
string _lbl_LE = lib_ema_enabled ? lib_ema_LE_source : (lib_rvol_enabled ? lib_rvol_LE_source : "Entry")
string _lbl_LX = lib_ema_enabled ? lib_ema_LX_source : (lib_rvol_enabled ? lib_rvol_LX_source : "Exit")
string _lbl_SE = lib_ema_enabled ? lib_ema_SE_source : (lib_rvol_enabled ? lib_rvol_SE_source : "Entry")
string _lbl_SX = lib_ema_enabled ? lib_ema_SX_source : (lib_rvol_enabled ? lib_rvol_SX_source : "Exit")

// V2 uses library-specific bull/bear label settings
bool _v2_LE_bull = lib_ema_enabled ? lib_ema_LE_bull : (lib_rvol_enabled ? lib_rvol_LE_bull : false)
bool _v2_LX_bear = lib_ema_enabled ? lib_ema_LX_bear : (lib_rvol_enabled ? lib_rvol_LX_bear : false)
bool _v2_SE_bear = lib_ema_enabled ? lib_ema_SE_bear : (lib_rvol_enabled ? lib_rvol_SE_bear : false)
bool _v2_SX_bull = lib_ema_enabled ? lib_ema_SX_bull : (lib_rvol_enabled ? lib_rvol_SX_bull : false)

// Calculate position quantities for labels
float _lbl_longQty  = _kb_calcQty(close, 1)
float _lbl_shortQty = _kb_calcQty(close, -1)
string _lbl_riskStr = riskMode == "Fixed $ Risk" ? str.tostring(defRisk, "#.##") : riskMode == "Percentage Risk" ? str.tostring(defRiskPct, "#.##") + "%" : str.tostring(defShares)

//──────────────────────────────────────────────────────────────────────────────
// 14.3.1 RAW TRIGGER LABELS (informational only)
//──────────────────────────────────────────────────────────────────────────────
// Note: Raw labels only show when position signal does NOT fire on same bar
// (to avoid duplicate labels - position labels have more info)

// Long Entry - Bullish Label (GREEN, BELOW candle)
// Only show raw label if position entry did NOT fire AND not exiting opposite direction
if barstate.islast == false and markLongEntry and _v2_LE_bull and not positionLongEntry and not positionShortExit
    label.new(
         bar_index, low,
         _lbl_LE,
         style    = label.style_label_up,
         color    = color.green,
         textcolor = color.white,
         size     = size.small
         )

// Long Exit - Transparent Red Label (ABOVE candle, bearish exit)
// Only show raw label if position exit did NOT fire AND not entering opposite direction
// Also suppress if Short Entry raw is showing (same trigger, prioritize entry)
if barstate.islast == false and markLongExit and _v2_LX_bear and not positionLongExit and not positionShortEntry and not markShortEntry
    label.new(
         bar_index, high,
         _lbl_LX,
         style    = label.style_label_down,
         color    = color.new(color.red, 50),
         textcolor = color.white,
         size     = size.small
         )

// Short Entry - Bearish Label (RED, ABOVE candle)
// Only show raw label if position entry did NOT fire AND not exiting opposite direction
if barstate.islast == false and markShortEntry and _v2_SE_bear and not positionShortEntry and not positionLongExit
    label.new(
         bar_index, high,
         _lbl_SE,
         style    = label.style_label_down,
         color    = color.red,
         textcolor = color.white,
         size     = size.small
         )

// Short Exit - Transparent Green Label (BELOW candle, bullish exit)
// Only show raw label if position exit did NOT fire AND not entering opposite direction
// Also suppress if Long Entry raw is showing (same trigger, prioritize entry)
if barstate.islast == false and markShortExit and _v2_SX_bull and not positionShortExit and not positionLongEntry and not markLongEntry
    label.new(
         bar_index, low,
         _lbl_SX,
         style    = label.style_label_up,
         color    = color.new(color.green, 50),
         textcolor = color.white,
         size     = size.small
         )

//──────────────────────────────────────────────────────────────────────────────
// 14.3.2 POSITION SIGNAL LABELS (with full metadata)
//──────────────────────────────────────────────────────────────────────────────

// Long Position Entry - Bullish Label with metadata (GREEN, BELOW candle)
if barstate.islast == false and positionLongEntry and _v2_LE_bull
    string _posLblLE = _kb_buildPosLabel(_lbl_LE, _kb_longGrade, "LONG", _lbl_longQty, _lbl_riskStr)
    label.new(
         bar_index, low,
         _posLblLE,
         style    = label.style_label_up,
         color    = color.green,
         textcolor = color.white,
         size     = size.normal
         )

// Long Position Exit - Transparent Red Label with metadata (ABOVE candle, bearish exit)
if barstate.islast == false and positionLongExit and _v2_LX_bear
    string _posLblLX = _kb_buildPosLabel(_lbl_LX, _kb_longGrade, "LONG EXIT", _lbl_longQty, _lbl_riskStr)
    label.new(
         bar_index, high,
         _posLblLX,
         style    = label.style_label_down,
         color    = color.new(color.red, 50),
         textcolor = color.white,
         size     = size.normal
         )

// Short Position Entry - Bearish Label with metadata (RED, ABOVE candle)
if barstate.islast == false and positionShortEntry and _v2_SE_bear
    string _posLblSE = _kb_buildPosLabel(_lbl_SE, _kb_shortGrade, "SHORT", _lbl_shortQty, _lbl_riskStr)
    label.new(
         bar_index, high,
         _posLblSE,
         style    = label.style_label_down,
         color    = color.red,
         textcolor = color.white,
         size     = size.normal
         )

// Short Position Exit - Transparent Green Label with metadata (BELOW candle, bullish exit)
if barstate.islast == false and positionShortExit and _v2_SX_bull
    string _posLblSX = _kb_buildPosLabel(_lbl_SX, _kb_shortGrade, "SHORT EXIT", _lbl_shortQty, _lbl_riskStr)
    label.new(
         bar_index, low,
         _posLblSX,
         style    = label.style_label_up,
         color    = color.new(color.green, 50),
         textcolor = color.white,
         size     = size.normal
         )

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 15. DATA EXPORT PLOTS
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// These plots are invisible on the chart but appear in CSV exports.
// Use TradingView's "Export chart data" to capture this information.
//
// ENCODING REFERENCE:
// Grades: 0=None, 1=C, 2=B, 3=A
// EMA Labels: 1=SML, 2=SLM, 3=MSL, 4=MLS, 5=LSM, 6=LMS, 0=Unknown

//──────────────────────────────────────────────────────────────────────────────
// 15.1 HELPERS - Encode strings to numbers for export
//──────────────────────────────────────────────────────────────────────────────

// Encode grade string to number
_kb_encodeGrade(string g) =>
    g == "A" ? 3 : g == "B" ? 2 : g == "C" ? 1 : 0

// Encode EMA label string to number
_kb_encodeEMALabel(string lbl) =>
    lbl == "SML" ? 1 : lbl == "SLM" ? 2 : lbl == "MSL" ? 3 : lbl == "MLS" ? 4 : lbl == "LSM" ? 5 : lbl == "LMS" ? 6 : 0

//──────────────────────────────────────────────────────────────────────────────
// 15.2 CONFLUENCE STATE EXPORTS
//──────────────────────────────────────────────────────────────────────────────

// Long Confluence
plot(_kb_longScore,  "Export: Long Score",  display = display.data_window)
plot(_kb_encodeGrade(_kb_longGrade), "Export: Long Grade (0=None,1=C,2=B,3=A)", display = display.data_window)

// Short Confluence
plot(_kb_shortScore, "Export: Short Score", display = display.data_window)
plot(_kb_encodeGrade(_kb_shortGrade), "Export: Short Grade (0=None,1=C,2=B,3=A)", display = display.data_window)

//──────────────────────────────────────────────────────────────────────────────
// 15.3 POSITION SIZING EXPORTS
//──────────────────────────────────────────────────────────────────────────────

plot(_lbl_longQty,  "Export: Long Qty",  display = display.data_window)
plot(_lbl_shortQty, "Export: Short Qty", display = display.data_window)

// Risk amount (actual dollar value based on risk mode)
float _export_riskAmt = riskMode == "Fixed $ Risk" ? defRisk : riskMode == "Percentage Risk" ? (acctSize * defRiskPct * 0.01) : na
plot(_export_riskAmt, "Export: Risk Amount ($)", display = display.data_window)

//──────────────────────────────────────────────────────────────────────────────
// 15.4 TIMEFRAME CONDITION STATE EXPORTS (Side Module 1)
//──────────────────────────────────────────────────────────────────────────────
// Exports the EMA ordering label for each timeframe as an encoded number
// 1=SML (Bull Stack), 2=SLM, 3=MSL, 4=MLS, 5=LSM, 6=LMS (Bear Stack), 0=Unknown

plot(_kb_encodeEMALabel(_side1_tf1_label), "Export: TF1 EMA State", display = display.data_window)
plot(_kb_encodeEMALabel(_side1_tf2_label), "Export: TF2 EMA State", display = display.data_window)
plot(_kb_encodeEMALabel(_side1_tf3_label), "Export: TF3 EMA State", display = display.data_window)
plot(_kb_encodeEMALabel(_side1_tf4_label), "Export: TF4 EMA State", display = display.data_window)
plot(_kb_encodeEMALabel(_side1_tf5_label), "Export: TF5 EMA State", display = display.data_window)
plot(_kb_encodeEMALabel(_side1_tf6_label), "Export: TF6 EMA State", display = display.data_window)

//──────────────────────────────────────────────────────────────────────────────
// 15.5 SIGNAL MARKERS FOR EXPORT
//──────────────────────────────────────────────────────────────────────────────
// These help identify which bars had entries/exits in the export

plot(positionLongEntry  ? 1 : 0, "Export: Pos Long Entry",  display = display.data_window)
plot(positionShortEntry ? 1 : 0, "Export: Pos Short Entry", display = display.data_window)
plot(positionLongExit   ? 1 : 0, "Export: Pos Long Exit",   display = display.data_window)
plot(positionShortExit  ? 1 : 0, "Export: Pos Short Exit",  display = display.data_window)

// Note: Trigger index exports simplified for v2 architecture
// Future: will export per-library trigger indices
plot(na, "Export: LE Trigger Idx", display = display.data_window)
plot(na, "Export: SE Trigger Idx", display = display.data_window)

//──────────────────────────────────────────────────────────────────────────────
// 15.6 EQUITY CURVE EXPORTS (Entry Price, SL, TP)
//──────────────────────────────────────────────────────────────────────────────
// These exports allow building a more realistic equity curve in a spreadsheet
// by using actual SL/TP prices instead of bar close for exits.
//
// USAGE IN SPREADSHEET:
// 1. Find entry bars (Pos Long Entry = 1 or Pos Short Entry = 1)
// 2. Capture Entry Price, SL Price, TP Price at entry
// 3. On subsequent bars, check if Low <= SL (stopped out) or High >= TP (target hit)
// 4. Use the appropriate exit price for PnL calculation

// Entry price (close of entry bar)
plot(positionLongEntry  ? close : na, "Export: Long Entry Price",  display = display.data_window)
plot(positionShortEntry ? close : na, "Export: Short Entry Price", display = display.data_window)

// SL Price calculation at entry (direction-aware)
// Long: SL is below entry | Short: SL is above entry
float _export_longSL = na
float _export_shortSL = na

if positionLongEntry
    if sl_method == "ATR"
        _export_longSL := close - ta.atr(sl_atrPer) * sl_atrMult
    else if sl_method == "Fixed Dollar"
        _export_longSL := close - sl_fixed
    else if sl_method == "Percentage"
        _export_longSL := close * (1 - sl_pct * 0.01)
    else if sl_method == "Candle Wicks"
        _export_longSL := low[sl_lookback] - sl_pad

if positionShortEntry
    if sl_method == "ATR"
        _export_shortSL := close + ta.atr(sl_atrPer) * sl_atrMult
    else if sl_method == "Fixed Dollar"
        _export_shortSL := close + sl_fixed
    else if sl_method == "Percentage"
        _export_shortSL := close * (1 + sl_pct * 0.01)
    else if sl_method == "Candle Wicks"
        _export_shortSL := high[sl_lookback] + sl_pad

plot(_export_longSL,  "Export: Long SL Price",  display = display.data_window)
plot(_export_shortSL, "Export: Short SL Price", display = display.data_window)

// TP Price calculation at entry (direction-aware)
// Long: TP is above entry | Short: TP is below entry
float _export_longTP = na
float _export_shortTP = na

// Calculate risk distance for R:R based TP
float _export_longRisk  = positionLongEntry  ? (close - nz(_export_longSL, close)) : na
float _export_shortRisk = positionShortEntry ? (nz(_export_shortSL, close) - close) : na

if positionLongEntry
    if tp_method == "Risk:Reward Target"
        _export_longTP := close + (_export_longRisk * tp_rr)
    else if tp_method == "ATR"
        _export_longTP := close + ta.atr(tp_atrPer) * tp_atrMult
    else if tp_method == "Fixed Dollar"
        _export_longTP := close + tp_fixed
    else if tp_method == "Percentage"
        _export_longTP := close * (1 + tp_pct * 0.01)
    else if tp_method == "Candle Wicks"
        _export_longTP := high[tp_lookback] + tp_pad

if positionShortEntry
    if tp_method == "Risk:Reward Target"
        _export_shortTP := close - (_export_shortRisk * tp_rr)
    else if tp_method == "ATR"
        _export_shortTP := close - ta.atr(tp_atrPer) * tp_atrMult
    else if tp_method == "Fixed Dollar"
        _export_shortTP := close - tp_fixed
    else if tp_method == "Percentage"
        _export_shortTP := close * (1 - tp_pct * 0.01)
    else if tp_method == "Candle Wicks"
        _export_shortTP := low[tp_lookback] - tp_pad

plot(_export_longTP,  "Export: Long TP Price",  display = display.data_window)
plot(_export_shortTP, "Export: Short TP Price", display = display.data_window)

// Risk amount in price terms (distance from entry to SL)
plot(_export_longRisk,  "Export: Long Risk (Price)",  display = display.data_window)
plot(_export_shortRisk, "Export: Short Risk (Price)", display = display.data_window)