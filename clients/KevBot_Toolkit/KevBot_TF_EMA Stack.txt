//@version=6
library("KevBot_TF_EMA_Stack", overlay = false)

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// KevBot_TF_EMA_Stack – EMA Stack Module for KevBot Toolkit (Hybrid Architecture)
//
// ARCHITECTURE NOTE:
//   This library uses the HYBRID approach where:
//   • The TOOLKIT owns all request.security() calls and input.*() declarations
//   • This library provides a BUILDER function that processes pre-fetched EMA data
//   • This allows paramA-F in the toolkit to control EMA lengths (optimizer compatible!)
//
// WHY THIS APPROACH:
//   PineScript has three limitations that prevent libraries from being fully modular:
//   1. request.security() cannot depend on function arguments
//   2. var variables don't persist in library exported functions
//   3. Exported functions cannot depend on input.*() variables
//
//   By having the toolkit fetch data and this library process it, we get the best
//   of both worlds: optimizer-friendly params AND modular processing logic.
//
// USAGE IN TOOLKIT:
//   // 1. Toolkit declares inputs (these ARE optimizable!)
//   int emaShort = int(side1_paramA)  // e.g., 10
//   int emaMed   = int(side1_paramB)  // e.g., 20
//   int emaLong  = int(side1_paramC)  // e.g., 50
//
//   // 2. Toolkit fetches HTF data for each timeframe
//   [eS1, eM1, eL1] = request.security(sym, tf1, [ta.ema(close, emaShort), ta.ema(close, emaMed), ta.ema(close, emaLong)])
//   ... repeat for tf2-tf6 ...
//
//   // 3. Toolkit calls this library's builder
//   TFModuleOutput output = emaStack.buildOutput(
//       eS1, eM1, eL1, eS2, eM2, eL2, ...,   // HTF EMAs
//       eS_chart, eM_chart, eL_chart,         // Chart TF EMAs for triggers
//       eS_prev, eM_prev, eL_prev             // Previous bar for crossovers
//   )
//
// CONDITIONS PROVIDED:
//   A: SML (Bull Stack - S > M > L)
//   B: LMS (Bear Stack - L > M > S)
//   C: SLM
//   D: MSL
//   E: MLS
//   F: LSM
//   G-J: Reserved (false)
//
// TRIGGERS PROVIDED:
//   A: Short crosses above Medium
//   B: Short crosses below Medium
//   C: Short crosses above Long
//   D: Short crosses below Long
//   E: Medium crosses above Long
//   F: Medium crosses below Long
//   G-J: Reserved (false)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// OUTPUT STRUCTURE - V2 Format (10 Conditions × 6 TFs + 10 Triggers)
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export type TFModuleOutput
    // Per-TF labels (state description)
    string tf1_label
    string tf2_label
    string tf3_label
    string tf4_label
    string tf5_label
    string tf6_label

    // Condition A per TF: SML (Bull Stack - S > M > L)
    bool condA_tf1
    bool condA_tf2
    bool condA_tf3
    bool condA_tf4
    bool condA_tf5
    bool condA_tf6

    // Condition B per TF: LMS (Bear Stack - L > M > S)
    bool condB_tf1
    bool condB_tf2
    bool condB_tf3
    bool condB_tf4
    bool condB_tf5
    bool condB_tf6

    // Condition C per TF: SLM
    bool condC_tf1
    bool condC_tf2
    bool condC_tf3
    bool condC_tf4
    bool condC_tf5
    bool condC_tf6

    // Condition D per TF: MSL
    bool condD_tf1
    bool condD_tf2
    bool condD_tf3
    bool condD_tf4
    bool condD_tf5
    bool condD_tf6

    // Condition E per TF: MLS
    bool condE_tf1
    bool condE_tf2
    bool condE_tf3
    bool condE_tf4
    bool condE_tf5
    bool condE_tf6

    // Condition F per TF: LSM
    bool condF_tf1
    bool condF_tf2
    bool condF_tf3
    bool condF_tf4
    bool condF_tf5
    bool condF_tf6

    // Conditions G-J per TF: Reserved (false)
    bool condG_tf1
    bool condG_tf2
    bool condG_tf3
    bool condG_tf4
    bool condG_tf5
    bool condG_tf6

    bool condH_tf1
    bool condH_tf2
    bool condH_tf3
    bool condH_tf4
    bool condH_tf5
    bool condH_tf6

    bool condI_tf1
    bool condI_tf2
    bool condI_tf3
    bool condI_tf4
    bool condI_tf5
    bool condI_tf6

    bool condJ_tf1
    bool condJ_tf2
    bool condJ_tf3
    bool condJ_tf4
    bool condJ_tf5
    bool condJ_tf6

    // Triggers A-J (chart timeframe events)
    bool trigA  // S crosses above M
    bool trigB  // S crosses below M
    bool trigC  // S crosses above L
    bool trigD  // S crosses below L
    bool trigE  // M crosses above L
    bool trigF  // M crosses below L
    bool trigG  // Reserved
    bool trigH  // Reserved
    bool trigI  // Reserved
    bool trigJ  // Reserved

    // Trigger metadata (for the active/primary trigger)
    float trigger_price
    string trigger_label

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// INTERNAL HELPERS
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Compute EMA ordering label from three EMA values.
_orderLabel(float eS, float eM, float eL) =>
    string lab = "na"
    if na(eS) or na(eM) or na(eL)
        lab := "na"
    else if eS > eM and eM > eL
        lab := "SML"
    else if eS > eL and eL > eM
        lab := "SLM"
    else if eM > eS and eS > eL
        lab := "MSL"
    else if eM > eL and eL > eS
        lab := "MLS"
    else if eL > eS and eS > eM
        lab := "LSM"
    else if eL > eM and eM > eS
        lab := "LMS"
    else
        lab := "EQ"
    lab

// Check individual EMA formations
_isSML(float eS, float eM, float eL) => not na(eS) and not na(eM) and not na(eL) and eS > eM and eM > eL
_isLMS(float eS, float eM, float eL) => not na(eS) and not na(eM) and not na(eL) and eL > eM and eM > eS
_isSLM(float eS, float eM, float eL) => not na(eS) and not na(eM) and not na(eL) and eS > eL and eL > eM
_isMSL(float eS, float eM, float eL) => not na(eS) and not na(eM) and not na(eL) and eM > eS and eS > eL
_isMLS(float eS, float eM, float eL) => not na(eS) and not na(eM) and not na(eL) and eM > eL and eL > eS
_isLSM(float eS, float eM, float eL) => not na(eS) and not na(eM) and not na(eL) and eL > eS and eS > eM

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// PUBLIC API - Builder Function
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Build TFModuleOutput from pre-fetched EMA data
// The toolkit calls this AFTER it has fetched all HTF EMAs using request.security()
//
// @param eS1-eL6  Short/Medium/Long EMAs for each of the 6 timeframes
// @param eS_chart, eM_chart, eL_chart  Current chart TF EMAs (for triggers)
// @param eS_prev, eM_prev, eL_prev     Previous bar EMAs (for crossover detection)
// @param triggerPrice                   Price to use for trigger metadata (usually close)
export buildOutput(
    float eS1, float eM1, float eL1,
    float eS2, float eM2, float eL2,
    float eS3, float eM3, float eL3,
    float eS4, float eM4, float eL4,
    float eS5, float eM5, float eL5,
    float eS6, float eM6, float eL6,
    float eS_chart, float eM_chart, float eL_chart,
    float eS_prev, float eM_prev, float eL_prev,
    float triggerPrice
) =>
    // Generate labels
    string lab1 = _orderLabel(eS1, eM1, eL1)
    string lab2 = _orderLabel(eS2, eM2, eL2)
    string lab3 = _orderLabel(eS3, eM3, eL3)
    string lab4 = _orderLabel(eS4, eM4, eL4)
    string lab5 = _orderLabel(eS5, eM5, eL5)
    string lab6 = _orderLabel(eS6, eM6, eL6)

    // Condition A: SML (Bull Stack) per TF
    bool cA1 = _isSML(eS1, eM1, eL1), bool cA2 = _isSML(eS2, eM2, eL2), bool cA3 = _isSML(eS3, eM3, eL3)
    bool cA4 = _isSML(eS4, eM4, eL4), bool cA5 = _isSML(eS5, eM5, eL5), bool cA6 = _isSML(eS6, eM6, eL6)

    // Condition B: LMS (Bear Stack) per TF
    bool cB1 = _isLMS(eS1, eM1, eL1), bool cB2 = _isLMS(eS2, eM2, eL2), bool cB3 = _isLMS(eS3, eM3, eL3)
    bool cB4 = _isLMS(eS4, eM4, eL4), bool cB5 = _isLMS(eS5, eM5, eL5), bool cB6 = _isLMS(eS6, eM6, eL6)

    // Condition C: SLM per TF
    bool cC1 = _isSLM(eS1, eM1, eL1), bool cC2 = _isSLM(eS2, eM2, eL2), bool cC3 = _isSLM(eS3, eM3, eL3)
    bool cC4 = _isSLM(eS4, eM4, eL4), bool cC5 = _isSLM(eS5, eM5, eL5), bool cC6 = _isSLM(eS6, eM6, eL6)

    // Condition D: MSL per TF
    bool cD1 = _isMSL(eS1, eM1, eL1), bool cD2 = _isMSL(eS2, eM2, eL2), bool cD3 = _isMSL(eS3, eM3, eL3)
    bool cD4 = _isMSL(eS4, eM4, eL4), bool cD5 = _isMSL(eS5, eM5, eL5), bool cD6 = _isMSL(eS6, eM6, eL6)

    // Condition E: MLS per TF
    bool cE1 = _isMLS(eS1, eM1, eL1), bool cE2 = _isMLS(eS2, eM2, eL2), bool cE3 = _isMLS(eS3, eM3, eL3)
    bool cE4 = _isMLS(eS4, eM4, eL4), bool cE5 = _isMLS(eS5, eM5, eL5), bool cE6 = _isMLS(eS6, eM6, eL6)

    // Condition F: LSM per TF
    bool cF1 = _isLSM(eS1, eM1, eL1), bool cF2 = _isLSM(eS2, eM2, eL2), bool cF3 = _isLSM(eS3, eM3, eL3)
    bool cF4 = _isLSM(eS4, eM4, eL4), bool cF5 = _isLSM(eS5, eM5, eL5), bool cF6 = _isLSM(eS6, eM6, eL6)

    // Triggers on chart timeframe (crossovers)
    bool tA = eS_prev <= eM_prev and eS_chart > eM_chart  // S crosses above M
    bool tB = eS_prev >= eM_prev and eS_chart < eM_chart  // S crosses below M
    bool tC = eS_prev <= eL_prev and eS_chart > eL_chart  // S crosses above L
    bool tD = eS_prev >= eL_prev and eS_chart < eL_chart  // S crosses below L
    bool tE = eM_prev <= eL_prev and eM_chart > eL_chart  // M crosses above L
    bool tF = eM_prev >= eL_prev and eM_chart < eL_chart  // M crosses below L

    // Handle na values in trigger detection
    tA := na(eS_prev) or na(eM_prev) or na(eS_chart) or na(eM_chart) ? false : tA
    tB := na(eS_prev) or na(eM_prev) or na(eS_chart) or na(eM_chart) ? false : tB
    tC := na(eS_prev) or na(eL_prev) or na(eS_chart) or na(eL_chart) ? false : tC
    tD := na(eS_prev) or na(eL_prev) or na(eS_chart) or na(eL_chart) ? false : tD
    tE := na(eM_prev) or na(eL_prev) or na(eM_chart) or na(eL_chart) ? false : tE
    tF := na(eM_prev) or na(eL_prev) or na(eM_chart) or na(eL_chart) ? false : tF

    // Determine trigger label
    bool anyTrig = tA or tB or tC or tD or tE or tF
    float trigPx = anyTrig ? triggerPrice : na
    string trigLab = tA ? "S>M" : tB ? "S<M" : tC ? "S>L" : tD ? "S<L" : tE ? "M>L" : tF ? "M<L" : "None"

    TFModuleOutput.new(
        // Labels
        lab1, lab2, lab3, lab4, lab5, lab6,
        // Cond A (SML)
        cA1, cA2, cA3, cA4, cA5, cA6,
        // Cond B (LMS)
        cB1, cB2, cB3, cB4, cB5, cB6,
        // Cond C (SLM)
        cC1, cC2, cC3, cC4, cC5, cC6,
        // Cond D (MSL)
        cD1, cD2, cD3, cD4, cD5, cD6,
        // Cond E (MLS)
        cE1, cE2, cE3, cE4, cE5, cE6,
        // Cond F (LSM)
        cF1, cF2, cF3, cF4, cF5, cF6,
        // Cond G-J (reserved, false)
        false, false, false, false, false, false,
        false, false, false, false, false, false,
        false, false, false, false, false, false,
        false, false, false, false, false, false,
        // Triggers A-J
        tA, tB, tC, tD, tE, tF, false, false, false, false,
        // Trigger metadata
        trigPx, trigLab
    )

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// LEGACY API - getTFConfluence (For backwards compatibility reference)
// NOTE: This function is DEPRECATED. Use buildOutput() with toolkit-fetched data.
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// REMOVED: The old getTFConfluence() function that used request.security()
// is no longer supported due to PineScript limitations.
//
// Migration path:
// 1. Toolkit fetches EMAs using request.security() with user-controlled params
// 2. Toolkit calls buildOutput() with the fetched values
// 3. This gives full optimizer compatibility while keeping processing modular
